//@version=6
indicator("LarsTrades Order Flow Zones", overlay=true, max_boxes_count=500, max_labels_count=500, max_lines_count=500)

// ============================================================================
// INPUTS
// ============================================================================

// Order Flow Settings
imbalanceRatio = input.float(3.0, "Imbalance Ratio Threshold", minval=2.0, step=0.1, group="Order Flow Detection")
minLevelVolume = input.int(10, "Min Volume Per Level", minval=1, group="Order Flow Detection")
priceLevelsPerBar = input.int(10, "Price Levels Per Bar", minval=5, maxval=20, group="Order Flow Detection")
barsToShow = input.int(6, "Bars to Show in History", minval=3, maxval=10, group="Order Flow Detection")

// Key Level Settings
maxKeyLevels = input.int(8, "Max Key Ranges to Track", minval=3, maxval=15, group="Key Levels")
rangeMergeTicks = input.float(5.0, "Range Merge Distance (Ticks)", minval=2.0, step=0.5, group="Key Levels")

// Tiering thresholds
extremeRatio = input.float(8.0, "EXTREME Tier Threshold", minval=6.0, step=0.5, group="Tiering")
strongRatio = input.float(5.0, "STRONG Tier Threshold", minval=4.0, step=0.5, group="Tiering")

// Display Settings
showBoxes = input.bool(true, "Show Imbalance Boxes", group="Display")
showTradeLines = input.bool(true, "Show Trade Lines", group="Display")
showClosedTradeBoxes = input.bool(true, "Show Closed Trade Boxes", group="Display")
closedTradeBoxOpacity = input.int(75, "Closed Box Opacity", minval=10, maxval=95, group="Display")
showTables = input.bool(true, "Show Tables", group="Display")
mobileCompact = input.bool(false, "Mobile Compact Mode", group="Display")

// Performance Controls
resetPerformance = input.bool(false, "Reset Performance", group="Performance")

// Trade Settings
minRR = input.float(3.0, "Minimum Risk:Reward Ratio", minval=2.0, step=0.5, group="Trade Logic")
rejectionBuffer = input.float(5.0, "Stop Loss Buffer (Ticks)", minval=1.0, step=0.5, group="Trade Logic")
profitConfirmBars = input.int(2, "Bars to Confirm Profit", minval=1, maxval=5, group="Trade Logic")
// New setting: number of bars to confirm a stop loss hit (Option C - give trades room to breathe)
stopConfirmBars   = input.int(2, "Bars to Confirm Stop Loss", minval=1, maxval=5, group="Trade Logic")
maxRR_input        = input.float(4.0,  "Maximum Risk:Reward Ratio", minval=0.0, step=0.5, group="Trade Logic")
maxRR = math.max(maxRR_input, minRR)
atrLength    = input.int(14,     "ATR Length",                minval=1,                group="Trade Logic")
atrMult      = input.float(0.5,  "ATR Multiplier",            minval=0.0, step=0.1,  group="Trade Logic")
minStopTicks = input.float(25.0, "Min Stop Size (Ticks)",     minval=1.0, step=1.0,  group="Trade Logic")
maxStopTicks = input.float(80.0, "Max Stop Size (Ticks)",     minval=5.0, step=1.0,  group="Trade Logic")
swingLookback = input.int(10, "Swing Lookback Bars", minval=1, maxval=100, group="Trade Logic")
showDebug = input.bool(false, "Dev: Show Stop/Target Debug", group = "Trade Logic")

// ----------------------------------------------------------------------------
// Trade Filter Settings
//
// These inputs allow users to filter trade setups based on the prevailing
// trend and the amount of opposing volume within a key imbalance.  The trend
// filter compares price to a simple moving average to determine whether the
// market is trending up or down.  The opposing volume filter rejects levels
// where too much volume comes from the opposite side of the imbalance.
// "Extreme" tiers can override the filters.
trendFilterEnabled = input.bool(true, "Use trend filter?", group="Trade Filter")
trendPeriod       = input.int(50, "Trend MA period", minval=10, maxval=200, group="Trade Filter")
maxOpposingPct    = input.float(0.10, "Max opposing volume %", minval=0.01, maxval=0.5, step=0.01, group="Trade Filter")

// Colors
col_buy = input.color(#00ff41, "Buy Color", group="Colors")
col_sell = input.color(#b968ff, "Sell Color", group="Colors")
col_stop = input.color(#ff0000, "Stop Loss Color", group="Colors")
col_target = input.color(#ffeb3b, "Take Profit Color", group="Colors")

// ============================================================================
// ORDER FLOW ENGINE
// ============================================================================

atr_value = ta.atr(atrLength)
bucket_size = atr_value / priceLevelsPerBar
float swingLowCalc = ta.lowest(low, swingLookback)
float swingHighCalc = ta.highest(high, swingLookback)

float barBuyVol = close > open ? volume * 0.7 : volume * 0.3
float barSellVol = close > open ? volume * 0.3 : volume * 0.7
float barDelta = barBuyVol - barSellVol

// ---------------------------------------------------------------------------
// Trend calculation for trade filtering
// Compute a simple moving average of the closing price over the user-specified
// period and derive a directional string.  When the close is above the
// moving average we consider the trend to be up, otherwise down.  These
// values are used later to determine whether a key level aligns with the
// prevailing market direction.
float trendMA = ta.sma(close, trendPeriod)
string trendDir = close > trendMA ? "up" : "down"
float atr = ta.atr(atrLength)

calc_bar_levels(int lookback_offset) =>
    if bar_index < lookback_offset
        [array.new_float(), array.new_float(), array.new_float()]
    else
        float h = high[lookback_offset]
        float l = low[lookback_offset]
        float c = close[lookback_offset]
        float o = open[lookback_offset]
        float v = volume[lookback_offset]
        
        if na(h) or na(l) or na(c) or na(o) or na(v)
            [array.new_float(), array.new_float(), array.new_float()]
        else
            float bar_buy = c > o ? v * 0.7 : v * 0.3
            float bar_sell = c > o ? v * 0.3 : v * 0.7
            
            var float[] prices = array.new_float()
            var float[] buys = array.new_float()
            var float[] sells = array.new_float()
            
            array.clear(prices)
            array.clear(buys)
            array.clear(sells)
            
            float bar_range = h - l
            
            if bar_range <= 0 or na(bar_range)
                [array.new_float(), array.new_float(), array.new_float()]
            else
                int levels = math.max(1, math.floor(bar_range / bucket_size))
                levels := math.min(levels, priceLevelsPerBar)
                
                float level_height = bar_range / levels
                
                for i = 0 to levels - 1
                    float lvl_bottom = l + (i * level_height)
                    float lvl_top = l + ((i + 1) * level_height)
                    float lvl_mid = (lvl_bottom + lvl_top) / 2
                    
                    float position_pct = (lvl_mid - l) / bar_range
                    float buy_weight = c > o ? position_pct : (1 - position_pct)
                    float sell_weight = 1 - buy_weight
                    
                    float level_buy = (bar_buy / levels) * (0.5 + buy_weight * 0.5)
                    float level_sell = (bar_sell / levels) * (0.5 + sell_weight * 0.5)
                    
                    array.push(prices, lvl_mid)
                    array.push(buys, level_buy)
                    array.push(sells, level_sell)
                
                [prices, buys, sells]

// ============================================================================
// KEY LEVEL MODEL
// ============================================================================

// Status states with ENTRY
var string STATE_ACTIVE = "ACTIVE"
var string STATE_ENTRY = "ENTRY"        // NEW: Trade setup ready
var string STATE_TESTING = "TESTING"    // Trade is live
var string STATE_PROFIT = "PROFIT"
var string STATE_HELD = "HELD"
var string STATE_REJECTED = "REJECTED"
var string STATE_CLOSED = "CLOSED"

// New state representing a losing trade.  When a trade is entered and the
// stop loss is confirmed, the level transitions to LOSS instead of REJECTED.
var string STATE_LOSS = "LOSS"

// Tier labels
var string TIER_EXTREME = "???"
var string TIER_STRONG = "??"
var string TIER_MODERATE = "?"

// Persistent arrays
var float[] kl_range_top = array.new_float()
var float[] kl_range_bottom = array.new_float()
var float[] kl_poc = array.new_float()
var float[] kl_swing_price = array.new_float()
var string[] kl_side = array.new_string()
var float[] kl_strength = array.new_float()
var float[] kl_peak_ratio = array.new_float()
var float[] kl_avg_ratio = array.new_float()
var float[] kl_poc_volume = array.new_float()
var string[] kl_tier = array.new_string()
var int[] kl_origin_bar = array.new_int()
var string[] kl_state = array.new_string()
var int[] kl_test_count = array.new_int()
var box[] kl_box = array.new_box()
var int[] kl_last_test_bar = array.new_int()

// Trade Engine v2 scaffolding
var int TE_STATE_ACTIVE = 0
var int TE_STATE_POSSIBLE = 1
var int TE_STATE_OPEN = 2
var int TE_STATE_CLOSED_WIN = 3
var int TE_STATE_CLOSED_LOSS = 4
var int TE_STATE_REJECTED = 5

var int[] trade_state = array.new_int()
var bool[] trade_opened = array.new_bool()
var float[] trade_entry = array.new_float()
var float[] trade_stop = array.new_float()
var float[] trade_target = array.new_float()
var float[] trade_ticks = array.new_float()

// Trade visualization arrays
var float[] kl_entry_price = array.new_float()
var float[] kl_stop_price = array.new_float()
var float[] kl_target_price = array.new_float()
var float[] kl_rr_ratio = array.new_float()
var line[] kl_entry_line = array.new_line()
var line[] kl_stop_line = array.new_line()
var line[] kl_target_line = array.new_line()
var label[] kl_trade_label = array.new_label()
var int[] kl_reject_count = array.new_int()
var string[] kl_outcome = array.new_string()
var float[] kl_realized_ticks = array.new_float()
var bool[] kl_closed_logged = array.new_bool()
var int[] trade_entry_bar = array.new_int()

// Dev debug overlay objects
var line debugEntryLine = na
var line debugStopLine = na
var line debugTargetLine = na
var label debugLabel = na

// Persistent storage for closed trades (per session)
var string[] closed_side = array.new_string()
var float[] closed_entry = array.new_float()
var float[] closed_stop = array.new_float()
var float[] closed_target = array.new_float()
var float[] closed_rr = array.new_float()
var float[] closed_ticks = array.new_float()
var float[] closed_trade_rr = array.new_float()
var string[] closed_result = array.new_string()
var box[] closed_trade_boxes = array.new_box()
var int[] trade_closed_bar = array.new_int()

// Trade lifecycle state machine
type Trade
    int id
    int kl_id
    int direction
    float entry
    float stop
    float take
    string status   // "set", "open", "closed"
    float pnlTicks

var Trade[] trades_set = array.new<Trade>()
var Trade[] trades_open = array.new<Trade>()
var Trade[] trades_closed = array.new<Trade>()
var int trade_seq = 0

var bool perfResetLatched = false

// Session management
var int last_session_day = 0
int current_day = dayofmonth(time)
clear_performance_history() =>
    array.clear(closed_side)
    array.clear(closed_entry)
    array.clear(closed_stop)
    array.clear(closed_target)
    array.clear(closed_rr)
    array.clear(closed_ticks)
    array.clear(closed_trade_rr)
    array.clear(closed_result)
    if array.size(closed_trade_boxes) > 0
        for i = 0 to array.size(closed_trade_boxes) - 1
            box.delete(array.get(closed_trade_boxes, i))
    array.clear(closed_trade_boxes)

if current_day != last_session_day
    if array.size(kl_box) > 0
        for i = 0 to array.size(kl_box) - 1
            box.delete(array.get(kl_box, i))
            if not na(array.get(kl_entry_line, i))
                line.delete(array.get(kl_entry_line, i))
            if not na(array.get(kl_stop_line, i))
                line.delete(array.get(kl_stop_line, i))
            if not na(array.get(kl_target_line, i))
                line.delete(array.get(kl_target_line, i))
            if not na(array.get(kl_trade_label, i))
                label.delete(array.get(kl_trade_label, i))
    array.clear(kl_range_top)
    array.clear(kl_range_bottom)
    array.clear(kl_poc)
    array.clear(kl_swing_price)
    array.clear(kl_side)
    array.clear(kl_strength)
    array.clear(kl_peak_ratio)
    array.clear(kl_avg_ratio)
    array.clear(kl_poc_volume)
    array.clear(kl_tier)
    array.clear(kl_origin_bar)
    array.clear(kl_state)
    array.clear(kl_test_count)
    array.clear(kl_box)
    array.clear(kl_last_test_bar)
    array.clear(kl_entry_price)
    array.clear(kl_stop_price)
    array.clear(kl_target_price)
    array.clear(kl_rr_ratio)
    array.clear(kl_entry_line)
    array.clear(kl_stop_line)
    array.clear(kl_target_line)
    array.clear(kl_trade_label)
    array.clear(kl_reject_count)
    array.clear(kl_outcome)
    array.clear(kl_realized_ticks)
    array.clear(kl_closed_logged)
    array.clear(trade_entry_bar)
    array.clear(trade_state)
    array.clear(trade_opened)
    array.clear(trade_entry)
    array.clear(trade_stop)
    array.clear(trade_target)
    array.clear(trade_ticks)
    array.clear(trade_closed_bar)
    array.clear(trades_set)
    array.clear(trades_open)
    array.clear(trades_closed)
    trade_seq := 0
    clear_performance_history()
    last_session_day := current_day

if resetPerformance and not perfResetLatched
    clear_performance_history()
    perfResetLatched := true
else if not resetPerformance
    perfResetLatched := false

record_closed_trade(int idx) =>
    if idx >= 0 and idx < array.size(kl_closed_logged) and not array.get(kl_closed_logged, idx)
        float entry = array.get(kl_entry_price, idx)
        float stop = array.get(kl_stop_price, idx)
        float target = array.get(kl_target_price, idx)
        string outcome_val = array.get(kl_outcome, idx)
        string side_val = array.get(kl_side, idx)
        float exit_price = outcome_val == "Profit" ? target : stop

        float risk_price = math.abs(entry - stop)
        float pnl_price = na
        if side_val == "buy"
            pnl_price := exit_price - entry
        else if side_val == "sell"
            pnl_price := entry - exit_price

        float realized_rr = na
        if risk_price > 0 and not na(pnl_price)
            realized_rr := pnl_price / risk_price

        array.push(closed_side, array.get(kl_side, idx))
        array.push(closed_entry, array.get(kl_entry_price, idx))
        array.push(closed_stop, array.get(kl_stop_price, idx))
        array.push(closed_target, array.get(kl_target_price, idx))
        array.push(closed_rr, array.get(kl_rr_ratio, idx))
        array.push(closed_ticks, array.get(kl_realized_ticks, idx))
        array.push(closed_trade_rr, realized_rr)
        array.push(closed_result, array.get(kl_outcome, idx))
        array.set(kl_closed_logged, idx, true)

finalize_close(int idx, string outcome, float ticks_val) =>
    // Skip if already logged or index is out of sync
    bool base_loggable = idx >= 0 and idx < array.size(kl_state) and idx < array.size(kl_closed_logged) and not array.get(kl_closed_logged, idx)
    int ts = idx >= 0 and idx < array.size(trade_state) ? array.get(trade_state, idx) : na
    bool trade_live = ts == TE_STATE_OPEN
    bool trade_entered = idx >= 0 and idx < array.size(trade_opened) ? array.get(trade_opened, idx) : false
    bool has_prices = idx < array.size(kl_entry_price) and idx < array.size(kl_stop_price) and not na(array.get(kl_entry_price, idx)) and not na(array.get(kl_stop_price, idx))
    bool already_closed = idx < array.size(trade_closed_bar) and not na(array.get(trade_closed_bar, idx))
    bool loggable = base_loggable and trade_live and trade_entered and has_prices and not already_closed
    if loggable
        array.set(kl_realized_ticks, idx, ticks_val)
        array.set(kl_outcome, idx, outcome)
        array.set(kl_state, idx, STATE_CLOSED)
        if idx < array.size(trade_state)
            array.set(trade_state, idx, outcome == "Profit" ? TE_STATE_CLOSED_WIN : TE_STATE_CLOSED_LOSS)
        array.set(kl_last_test_bar, idx, bar_index)
        if idx < array.size(trade_closed_bar)
            array.set(trade_closed_bar, idx, bar_index)
        record_closed_trade(idx)

        // Draw a persistent closed-trade box from entry to exit
        float entry_price = array.get(kl_entry_price, idx)
        float exit_price = outcome == "Profit" ? array.get(kl_target_price, idx) : array.get(kl_stop_price, idx)
        int entry_bar_idx = idx < array.size(trade_entry_bar) and not na(array.get(trade_entry_bar, idx)) ? array.get(trade_entry_bar, idx) : bar_index
        float top = math.max(entry_price, exit_price)
        float bottom = math.min(entry_price, exit_price)
        color box_col = color.new(color.white, closedTradeBoxOpacity)
        box closed_box = box.new(left=entry_bar_idx, top=top, right=bar_index + 1, bottom=bottom, border_color=box_col, bgcolor=box_col, border_width=1)
        array.push(closed_trade_boxes, closed_box)

        int max_closed_boxes = 60
        if array.size(closed_trade_boxes) > max_closed_boxes
            box.delete(array.shift(closed_trade_boxes))

find_trade_index(Trade[] arr, int kl_idx) =>
    int found = -1
    for i = 0 to array.size(arr) - 1
        Trade t = array.get(arr, i)
        if t.kl_id == kl_idx
            found := i
            break
    found

swap_trade_indices(int a, int b) =>
    Trade[] arr_ref = trades_set
    for i = 0 to array.size(arr_ref) - 1
        Trade t = array.get(arr_ref, i)
        if t.kl_id == a
            t.kl_id := b
            array.set(arr_ref, i, t)
        else if t.kl_id == b
            t.kl_id := a
            array.set(arr_ref, i, t)

    arr_ref := trades_open
    for i = 0 to array.size(arr_ref) - 1
        Trade t = array.get(arr_ref, i)
        if t.kl_id == a
            t.kl_id := b
            array.set(arr_ref, i, t)
        else if t.kl_id == b
            t.kl_id := a
            array.set(arr_ref, i, t)

    arr_ref := trades_closed
    for i = 0 to array.size(arr_ref) - 1
        Trade t = array.get(arr_ref, i)
        if t.kl_id == a
            t.kl_id := b
            array.set(arr_ref, i, t)
        else if t.kl_id == b
            t.kl_id := a
            array.set(arr_ref, i, t)

remove_trades_for_index(int idx) =>
    int remove_i = find_trade_index(trades_set, idx)
    if remove_i != -1
        array.remove(trades_set, remove_i)

    remove_i := find_trade_index(trades_open, idx)
    if remove_i != -1
        array.remove(trades_open, remove_i)

register_set_trade(int kl_idx) =>
    if kl_idx >= 0 and kl_idx < array.size(kl_entry_price)
        float entry = array.get(kl_entry_price, kl_idx)
        float stop = array.get(kl_stop_price, kl_idx)
        float take = array.get(kl_target_price, kl_idx)
        string side = array.get(kl_side, kl_idx)
        if not na(entry) and not na(stop) and not na(take) and (side == "buy" or side == "sell")
            int dir = side == "buy" ? 1 : -1
            int existing_open = find_trade_index(trades_open, kl_idx)
            if existing_open == -1
                int existing_set = find_trade_index(trades_set, kl_idx)
                Trade t = existing_set == -1 ? Trade.new(0, kl_idx, dir, entry, stop, take, "set", na) : array.get(trades_set, existing_set)
                if existing_set == -1
                    trade_seq += 1
                    t.id := trade_seq
                t.kl_id := kl_idx
                t.direction := dir
                t.entry := entry
                t.stop := stop
                t.take := take
                t.status := "set"
                t.pnlTicks := na
                if existing_set == -1
                    array.push(trades_set, t)
                else
                    array.set(trades_set, existing_set, t)
                if kl_idx < array.size(trade_state)
                    array.set(trade_state, kl_idx, TE_STATE_POSSIBLE)
                if kl_idx < array.size(trade_opened)
                    array.set(trade_opened, kl_idx, false)
                if kl_idx < array.size(trade_entry)
                    array.set(trade_entry, kl_idx, entry)
                if kl_idx < array.size(trade_stop)
                    array.set(trade_stop, kl_idx, stop)
                if kl_idx < array.size(trade_target)
                    array.set(trade_target, kl_idx, take)
                if kl_idx < array.size(trade_ticks)
                    array.set(trade_ticks, kl_idx, na)
                if kl_idx < array.size(trade_entry_bar)
                    array.set(trade_entry_bar, kl_idx, na)
                if kl_idx < array.size(trade_closed_bar)
                    array.set(trade_closed_bar, kl_idx, na)

open_trade_for_level(int kl_idx) =>
    int idx_set = find_trade_index(trades_set, kl_idx)
    if idx_set != -1
        Trade t = array.get(trades_set, idx_set)
        array.remove(trades_set, idx_set)
        t.status := "open"
        array.push(trades_open, t)
        if kl_idx < array.size(trade_state)
            array.set(trade_state, kl_idx, TE_STATE_OPEN)
        if kl_idx < array.size(trade_opened)
            array.set(trade_opened, kl_idx, true)
        if kl_idx < array.size(trade_entry_bar)
            array.set(trade_entry_bar, kl_idx, bar_index)
        if kl_idx < array.size(kl_state)
            array.set(kl_state, kl_idx, STATE_TESTING)
            array.set(kl_last_test_bar, kl_idx, bar_index)

reject_trade_for_level(int kl_idx) =>
    int idx_set = find_trade_index(trades_set, kl_idx)
    if idx_set != -1
        array.remove(trades_set, idx_set)
    if kl_idx < array.size(trade_state)
        array.set(trade_state, kl_idx, TE_STATE_REJECTED)
    if kl_idx < array.size(kl_state)
        array.set(kl_state, kl_idx, STATE_REJECTED)
        array.set(kl_outcome, kl_idx, "Rejected")
        array.set(kl_realized_ticks, kl_idx, na)

close_open_trade(int kl_idx, float exit_price, string outcome) =>
    int idx_open = find_trade_index(trades_open, kl_idx)
    if idx_open != -1
        Trade t = array.get(trades_open, idx_open)
        array.remove(trades_open, idx_open)
        t.status := "closed"
        t.pnlTicks := (exit_price - t.entry) / syminfo.mintick * t.direction
        array.push(trades_closed, t)
        if kl_idx < array.size(trade_ticks)
            array.set(trade_ticks, kl_idx, t.pnlTicks)
        finalize_close(kl_idx, outcome, t.pnlTicks)

process_open_trade_bar(int kl_idx, string side, int test_count, int reject_count) =>
    int open_idx = find_trade_index(trades_open, kl_idx)
    if open_idx != -1
        Trade t_open = array.get(trades_open, open_idx)
        float stop = t_open.stop
        float target = t_open.take

        bool hit_target = side == "buy" ? (not na(target) and high >= target) : (not na(target) and low <= target)
        bool stop_condition = side == "buy" ? (not na(stop) and close < stop) : (not na(stop) and close > stop)

        if hit_target
            array.set(kl_test_count, kl_idx, test_count + 1)
            array.set(kl_reject_count, kl_idx, 0)
            close_open_trade(kl_idx, target, "Profit")
        else
            if stop_condition
                reject_count := reject_count + 1
            else
                reject_count := 0
            array.set(kl_reject_count, kl_idx, reject_count)
            if stop_condition and reject_count >= stopConfirmBars
                close_open_trade(kl_idx, stop, "Loss")

get_tier(float peak_ratio) =>
    if peak_ratio >= extremeRatio
        TIER_EXTREME
    else if peak_ratio >= strongRatio
        TIER_STRONG
    else
        TIER_MODERATE

get_tier_rank(string tier) =>
    tier == TIER_EXTREME ? 3 : tier == TIER_STRONG ? 2 : 1

// Function to find the nearest opposing imbalance POC for take profit
find_next_target(int current_idx, string current_side) =>
    float current_poc = array.get(kl_poc, current_idx)
    float target = na
    float best_dist = na

    if array.size(kl_poc) > 0
        for i = 0 to array.size(kl_poc) - 1
            if i != current_idx
                string side = array.get(kl_side, i)
                float poc = array.get(kl_poc, i)
                string state = array.get(kl_state, i)

                // Only consider active/entry/testing levels (not rejected) on the opposing side
                bool valid_buy_target = current_side == "buy" and side == "sell" and poc > current_poc
                bool valid_sell_target = current_side == "sell" and side == "buy" and poc < current_poc
                if state != STATE_REJECTED and (valid_buy_target or valid_sell_target)
                    float dist = math.abs(poc - current_poc)
                    if na(best_dist) or dist < best_dist
                        best_dist := dist
                        target := poc

    target

// Create a trade for a given key level index using the unified swing + ATR stop
// model and RR-banded target selection. Returns true on success.
create_trade_for_level(int idx) =>
    string side = array.get(kl_side, idx)
    float poc = array.get(kl_poc, idx)

    if na(side)
        false
    else
        float storedSwing = array.get(kl_swing_price, idx)
        float swingPrice = na
        if not na(storedSwing)
            swingPrice := storedSwing
        else
            swingPrice := side == "buy" ? swingLowCalc : swingHighCalc

        if na(storedSwing) and not na(swingPrice)
            array.set(kl_swing_price, idx, swingPrice)

        if na(swingPrice)
            false
        else
            float swingDistTicks = math.abs(poc - swingPrice) / syminfo.mintick
            float atrTicks = atr / syminfo.mintick
            float rawStopTicks = swingDistTicks + (atrTicks * atrMult)
            float clampedStopTicks = math.max(minStopTicks, math.min(rawStopTicks, maxStopTicks))
            float stop = side == "buy" ? poc - clampedStopTicks * syminfo.mintick : poc + clampedStopTicks * syminfo.mintick
            float risk = math.abs(poc - stop)

            if risk <= 0
                false
            else
                float level_target = find_next_target(idx, side)

                float target_to_use = na
                float rr_to_use = na

                if not na(level_target)
                    float reward_level = math.abs(level_target - poc)
                    float rr_level = risk > 0 ? reward_level / risk : na
                    if not na(rr_level) and rr_level >= minRR and rr_level <= maxRR
                        target_to_use := level_target
                        rr_to_use := rr_level

                if na(target_to_use) or na(rr_to_use)
                    float dir = side == "buy" ? 1.0 : -1.0
                    target_to_use := poc + dir * (risk * minRR)
                    rr_to_use := minRR

                if rr_to_use > maxRR
                    float dir = side == "buy" ? 1.0 : -1.0
                    target_to_use := poc + dir * (risk * maxRR)
                    rr_to_use := maxRR

                array.set(kl_entry_price, idx, poc)
                array.set(kl_stop_price, idx, stop)
                array.set(kl_target_price, idx, target_to_use)
                array.set(kl_rr_ratio, idx, rr_to_use)
                array.set(kl_state, idx, STATE_ENTRY)
                array.set(kl_last_test_bar, idx, bar_index)

                array.set(trade_state, idx, TE_STATE_POSSIBLE)
                array.set(trade_opened, idx, false)
                array.set(trade_entry, idx, poc)
                array.set(trade_stop, idx, stop)
                array.set(trade_target, idx, target_to_use)
                array.set(trade_ticks, idx, na)

                register_set_trade(idx)

                true

// ============================================================================
// IMBALANCE DETECTION
// ============================================================================

if barstate.isconfirmed
    [prices, buys, sells] = calc_bar_levels(0)
    
    var float[] raw_prices = array.new_float()
    var float[] raw_buy_vols = array.new_float()
    var float[] raw_sell_vols = array.new_float()
    var float[] raw_ratios = array.new_float()
    var string[] raw_sides = array.new_string()
    
    array.clear(raw_prices)
    array.clear(raw_buy_vols)
    array.clear(raw_sell_vols)
    array.clear(raw_ratios)
    array.clear(raw_sides)
    
    if array.size(prices) > 0
        for i = 0 to array.size(prices) - 1
            float price = array.get(prices, i)
            float buy_vol = array.get(buys, i)
            float sell_vol = array.get(sells, i)
            float total_vol = buy_vol + sell_vol
            
            float ratio = buy_vol >= sell_vol ? buy_vol / math.max(sell_vol, 1) : sell_vol / math.max(buy_vol, 1)
            
            if ratio >= imbalanceRatio and total_vol >= minLevelVolume
                array.push(raw_prices, price)
                array.push(raw_buy_vols, buy_vol)
                array.push(raw_sell_vols, sell_vol)
                array.push(raw_ratios, ratio)
                array.push(raw_sides, buy_vol > sell_vol ? "buy" : "sell")
    
    if array.size(raw_prices) > 0
        float merge_distance = rangeMergeTicks * syminfo.mintick
        
        for i = 0 to array.size(raw_prices) - 1
            float price = array.get(raw_prices, i)
            float buy_vol = array.get(raw_buy_vols, i)
            float sell_vol = array.get(raw_sell_vols, i)
            float ratio = array.get(raw_ratios, i)
            string side = array.get(raw_sides, i)
            float delta = buy_vol - sell_vol
            
            bool merged = false
            float swingLowRef = swingLowCalc
            float swingHighRef = swingHighCalc
            if array.size(kl_range_top) > 0
                for j = 0 to array.size(kl_range_top) - 1
                    if array.get(kl_side, j) == side
                        float range_top = array.get(kl_range_top, j)
                        float range_bottom = array.get(kl_range_bottom, j)
                        
                        if (price >= range_bottom - merge_distance) and (price <= range_top + merge_distance)
                            float new_top = math.max(range_top, price + bucket_size / 2)
                            float new_bottom = math.min(range_bottom, price - bucket_size / 2)
                            
                            array.set(kl_range_top, j, new_top)
                            array.set(kl_range_bottom, j, new_bottom)
                            
                            float current_peak = array.get(kl_peak_ratio, j)
                            if ratio > current_peak
                                array.set(kl_peak_ratio, j, ratio)
                                array.set(kl_poc, j, price)
                                array.set(kl_poc_volume, j, buy_vol + sell_vol)
                                array.set(kl_tier, j, get_tier(ratio))
                            
                            float current_avg = array.get(kl_avg_ratio, j)
                            float new_avg = (current_avg + ratio) / 2
                            array.set(kl_avg_ratio, j, new_avg)
                            
                            float total_delta = math.abs(delta)
                            float peak_ratio = array.get(kl_peak_ratio, j)
                            float new_strength = (total_delta * peak_ratio) / 100
                            array.set(kl_strength, j, new_strength)

                            // Seed a reference swing for this level if it has not been captured yet
                            if na(array.get(kl_swing_price, j))
                                float swing_ref_existing = side == "buy" ? swingLowRef : swingHighRef
                                array.set(kl_swing_price, j, swing_ref_existing)

                            array.set(kl_origin_bar, j, bar_index)
                            merged := true
                            break
            
            if not merged
                float range_top = price + bucket_size
                float range_bottom = price - bucket_size
                float strength = (math.abs(delta) * ratio) / 100
                string tier = get_tier(ratio)
                float swing_ref = side == "buy" ? swingLowRef : swingHighRef

                array.push(kl_range_top, range_top)
                array.push(kl_range_bottom, range_bottom)
                array.push(kl_poc, price)
                array.push(kl_swing_price, swing_ref)
                array.push(kl_side, side)
                array.push(kl_strength, strength)
                array.push(kl_peak_ratio, ratio)
                array.push(kl_avg_ratio, ratio)
                array.push(kl_poc_volume, buy_vol + sell_vol)
                array.push(kl_tier, tier)
                array.push(kl_origin_bar, bar_index)
                array.push(kl_state, STATE_ACTIVE)
                array.push(kl_test_count, 0)
                array.push(kl_last_test_bar, 0)
                array.push(kl_entry_price, na)
                array.push(kl_stop_price, na)
                array.push(kl_target_price, na)
                array.push(kl_rr_ratio, na)
                array.push(kl_outcome, "")
                array.push(kl_realized_ticks, na)
                // Initialize line/label IDs as na (uninitialized)
                array.push(kl_entry_line, na)
                array.push(kl_stop_line, na)
                array.push(kl_target_line, na)
                array.push(kl_trade_label, na)
                array.push(kl_reject_count, 0)
                array.push(kl_closed_logged, false)

                color box_color = side == "buy" ? color.new(col_buy, 70) : color.new(col_sell, 70)
                box new_box = box.new(left=bar_index, top=range_top, right=bar_index + 1, bottom=range_bottom, border_color=box_color, bgcolor=box_color, border_width=1)
                array.push(kl_box, new_box)
                array.push(trade_state, TE_STATE_ACTIVE)
                array.push(trade_opened, false)
                array.push(trade_entry, na)
                array.push(trade_stop, na)
                array.push(trade_target, na)
                array.push(trade_ticks, na)
                array.push(trade_entry_bar, na)
                array.push(trade_closed_bar, na)

                // Immediately build a trade setup for this new key level.
                // This uses the unified swing+ATR stop and RR-banded target logic.
                int new_idx = array.size(kl_state) - 1

                bool created_setup = create_trade_for_level(new_idx)

                // If creation failed (no valid swing, zero risk, etc), leave the level in STATE_ACTIVE
                // with empty prices so that the ACTIVE ? ENTRY logic can try again on a later touch.
                if not created_setup
                    array.set(kl_last_test_bar, new_idx, bar_index)
    
    // Sort by tier then strength
    if array.size(kl_strength) > 1
        int n = array.size(kl_strength)
        for i = 0 to n - 2
            for j = 0 to n - 2 - i
                string tier_j = array.get(kl_tier, j)
                string tier_j1 = array.get(kl_tier, j + 1)
                int rank_j = get_tier_rank(tier_j)
                int rank_j1 = get_tier_rank(tier_j1)
                
                bool should_swap = false
                if rank_j < rank_j1
                    should_swap := true
                else if rank_j == rank_j1 and array.get(kl_strength, j) < array.get(kl_strength, j + 1)
                    should_swap := true
                
                if should_swap
                    // Swap all arrays (keeping it compact)
                    float tmp_f = array.get(kl_range_top, j)
                    array.set(kl_range_top, j, array.get(kl_range_top, j + 1))
                    array.set(kl_range_top, j + 1, tmp_f)
                    
                    tmp_f := array.get(kl_range_bottom, j)
                    array.set(kl_range_bottom, j, array.get(kl_range_bottom, j + 1))
                    array.set(kl_range_bottom, j + 1, tmp_f)
                    
                    tmp_f := array.get(kl_poc, j)
                    array.set(kl_poc, j, array.get(kl_poc, j + 1))
                    array.set(kl_poc, j + 1, tmp_f)

                    tmp_f := array.get(kl_swing_price, j)
                    array.set(kl_swing_price, j, array.get(kl_swing_price, j + 1))
                    array.set(kl_swing_price, j + 1, tmp_f)

                    string tmp_s = array.get(kl_side, j)
                    array.set(kl_side, j, array.get(kl_side, j + 1))
                    array.set(kl_side, j + 1, tmp_s)
                    
                    tmp_f := array.get(kl_strength, j)
                    array.set(kl_strength, j, array.get(kl_strength, j + 1))
                    array.set(kl_strength, j + 1, tmp_f)
                    
                    tmp_f := array.get(kl_peak_ratio, j)
                    array.set(kl_peak_ratio, j, array.get(kl_peak_ratio, j + 1))
                    array.set(kl_peak_ratio, j + 1, tmp_f)
                    
                    tmp_f := array.get(kl_avg_ratio, j)
                    array.set(kl_avg_ratio, j, array.get(kl_avg_ratio, j + 1))
                    array.set(kl_avg_ratio, j + 1, tmp_f)
                    
                    tmp_f := array.get(kl_poc_volume, j)
                    array.set(kl_poc_volume, j, array.get(kl_poc_volume, j + 1))
                    array.set(kl_poc_volume, j + 1, tmp_f)
                    
                    tmp_s := array.get(kl_tier, j)
                    array.set(kl_tier, j, array.get(kl_tier, j + 1))
                    array.set(kl_tier, j + 1, tmp_s)
                    
                    int tmp_i = array.get(kl_origin_bar, j)
                    array.set(kl_origin_bar, j, array.get(kl_origin_bar, j + 1))
                    array.set(kl_origin_bar, j + 1, tmp_i)
                    
                    tmp_s := array.get(kl_state, j)
                    array.set(kl_state, j, array.get(kl_state, j + 1))
                    array.set(kl_state, j + 1, tmp_s)
                    
                    tmp_i := array.get(kl_test_count, j)
                    array.set(kl_test_count, j, array.get(kl_test_count, j + 1))
                    array.set(kl_test_count, j + 1, tmp_i)
                    
                    tmp_i := array.get(kl_last_test_bar, j)
                    array.set(kl_last_test_bar, j, array.get(kl_last_test_bar, j + 1))
                    array.set(kl_last_test_bar, j + 1, tmp_i)

                    tmp_s := array.get(kl_outcome, j)
                    array.set(kl_outcome, j, array.get(kl_outcome, j + 1))
                    array.set(kl_outcome, j + 1, tmp_s)

                    tmp_f := array.get(kl_realized_ticks, j)
                    array.set(kl_realized_ticks, j, array.get(kl_realized_ticks, j + 1))
                    array.set(kl_realized_ticks, j + 1, tmp_f)
                    
                    box tmp_box = array.get(kl_box, j)
                    array.set(kl_box, j, array.get(kl_box, j + 1))
                    array.set(kl_box, j + 1, tmp_box)
                    
                    tmp_f := array.get(kl_entry_price, j)
                    array.set(kl_entry_price, j, array.get(kl_entry_price, j + 1))
                    array.set(kl_entry_price, j + 1, tmp_f)
                    
                    tmp_f := array.get(kl_stop_price, j)
                    array.set(kl_stop_price, j, array.get(kl_stop_price, j + 1))
                    array.set(kl_stop_price, j + 1, tmp_f)
                    
                    tmp_f := array.get(kl_target_price, j)
                    array.set(kl_target_price, j, array.get(kl_target_price, j + 1))
                    array.set(kl_target_price, j + 1, tmp_f)
                    
                    tmp_f := array.get(kl_rr_ratio, j)
                    array.set(kl_rr_ratio, j, array.get(kl_rr_ratio, j + 1))
                    array.set(kl_rr_ratio, j + 1, tmp_f)
                    
                    line tmp_line = array.get(kl_entry_line, j)
                    array.set(kl_entry_line, j, array.get(kl_entry_line, j + 1))
                    array.set(kl_entry_line, j + 1, tmp_line)
                    
                    tmp_line := array.get(kl_stop_line, j)
                    array.set(kl_stop_line, j, array.get(kl_stop_line, j + 1))
                    array.set(kl_stop_line, j + 1, tmp_line)
                    
                    tmp_line := array.get(kl_target_line, j)
                    array.set(kl_target_line, j, array.get(kl_target_line, j + 1))
                    array.set(kl_target_line, j + 1, tmp_line)
                    
                    label tmp_label = array.get(kl_trade_label, j)
                    array.set(kl_trade_label, j, array.get(kl_trade_label, j + 1))
                    array.set(kl_trade_label, j + 1, tmp_label)
                    
                    tmp_i := array.get(kl_reject_count, j)
                    array.set(kl_reject_count, j, array.get(kl_reject_count, j + 1))
                    array.set(kl_reject_count, j + 1, tmp_i)

                    tmp_i := array.get(trade_state, j)
                    array.set(trade_state, j, array.get(trade_state, j + 1))
                    array.set(trade_state, j + 1, tmp_i)

                    bool tmp_open = array.get(trade_opened, j)
                    array.set(trade_opened, j, array.get(trade_opened, j + 1))
                    array.set(trade_opened, j + 1, tmp_open)

                    tmp_i := array.get(trade_entry_bar, j)
                    array.set(trade_entry_bar, j, array.get(trade_entry_bar, j + 1))
                    array.set(trade_entry_bar, j + 1, tmp_i)

                    tmp_i := array.get(trade_closed_bar, j)
                    array.set(trade_closed_bar, j, array.get(trade_closed_bar, j + 1))
                    array.set(trade_closed_bar, j + 1, tmp_i)

                    bool tmp_b = array.get(kl_closed_logged, j)
                    array.set(kl_closed_logged, j, array.get(kl_closed_logged, j + 1))
                    array.set(kl_closed_logged, j + 1, tmp_b)

                    tmp_f := array.get(trade_entry, j)
                    array.set(trade_entry, j, array.get(trade_entry, j + 1))
                    array.set(trade_entry, j + 1, tmp_f)

                    tmp_f := array.get(trade_stop, j)
                    array.set(trade_stop, j, array.get(trade_stop, j + 1))
                    array.set(trade_stop, j + 1, tmp_f)

                    tmp_f := array.get(trade_target, j)
                    array.set(trade_target, j, array.get(trade_target, j + 1))
                    array.set(trade_target, j + 1, tmp_f)

                    tmp_f := array.get(trade_ticks, j)
                    array.set(trade_ticks, j, array.get(trade_ticks, j + 1))
                    array.set(trade_ticks, j + 1, tmp_f)

                    swap_trade_indices(j, j + 1)
        
        while array.size(kl_strength) > maxKeyLevels
            int drop_idx = array.size(kl_entry_line) - 1
            if not na(array.get(kl_entry_line, drop_idx))
                line.delete(array.get(kl_entry_line, drop_idx))
            if not na(array.get(kl_stop_line, drop_idx))
                line.delete(array.get(kl_stop_line, drop_idx))
            if not na(array.get(kl_target_line, drop_idx))
                line.delete(array.get(kl_target_line, drop_idx))
            if not na(array.get(kl_trade_label, drop_idx))
                label.delete(array.get(kl_trade_label, drop_idx))
            box.delete(array.get(kl_box, drop_idx))

            remove_trades_for_index(drop_idx)

            array.pop(kl_range_top)
            array.pop(kl_range_bottom)
            array.pop(kl_poc)
            array.pop(kl_swing_price)
            array.pop(kl_side)
            array.pop(kl_strength)
            array.pop(kl_peak_ratio)
            array.pop(kl_avg_ratio)
            array.pop(kl_poc_volume)
            array.pop(kl_tier)
            array.pop(kl_origin_bar)
            array.pop(kl_state)
            array.pop(kl_test_count)
            array.pop(kl_last_test_bar)
            array.pop(kl_outcome)
            array.pop(kl_realized_ticks)
            array.pop(kl_box)
            array.pop(kl_entry_price)
            array.pop(kl_stop_price)
            array.pop(kl_target_price)
            array.pop(kl_rr_ratio)
            array.pop(kl_entry_line)
            array.pop(kl_stop_line)
            array.pop(kl_target_line)
            array.pop(kl_trade_label)
            array.pop(kl_reject_count)
            array.pop(trade_state)
            array.pop(trade_opened)
            array.pop(trade_entry)
            array.pop(trade_stop)
            array.pop(trade_target)
            array.pop(trade_ticks)
            array.pop(trade_entry_bar)
            array.pop(trade_closed_bar)
            array.pop(kl_closed_logged)

// ============================================================================
// LIFECYCLE UPDATE WITH ENTRY STATUS AND TRADE SETUP
// ============================================================================

if array.size(kl_state) > 0
    for i = 0 to array.size(kl_state) - 1
        if i < array.size(kl_state)
            string current_state = array.get(kl_state, i)
            string side = array.get(kl_side, i)
            float range_top = array.get(kl_range_top, i)
            float range_bottom = array.get(kl_range_bottom, i)
            float poc = array.get(kl_poc, i)
            int test_count = array.get(kl_test_count, i)
            int last_test = array.get(kl_last_test_bar, i)
            int reject_count = array.get(kl_reject_count, i)

            float reject_buffer = rejectionBuffer * syminfo.mintick

            if current_state == STATE_PROFIT or current_state == STATE_LOSS
                int ts_closed = i < array.size(trade_state) ? array.get(trade_state, i) : na
                bool trade_live = ts_closed == TE_STATE_OPEN
                bool already_closed = i < array.size(trade_closed_bar) and not na(array.get(trade_closed_bar, i))
                float entry_price = array.get(kl_entry_price, i)
                float stop_price = array.get(kl_stop_price, i)
                float target_price = array.get(kl_target_price, i)
                bool has_exit = current_state == STATE_PROFIT ? not na(target_price) : not na(stop_price)
                if trade_live and not already_closed and not na(entry_price) and not na(stop_price) and has_exit
                    float exit_price = current_state == STATE_PROFIT ? target_price : stop_price
                    float ticks_val = side == "buy" ? (exit_price - entry_price) / syminfo.mintick : (entry_price - exit_price) / syminfo.mintick
                    finalize_close(i, current_state == STATE_PROFIT ? "Profit" : "Loss", ticks_val)

            // ACTIVE ? ENTRY (find valid trade setup)
            else if current_state == STATE_ACTIVE
                // Only attempt to create a setup if we do not already have entry/stop/target prices from initial creation.
                bool has_setup = i < array.size(kl_entry_price) and not na(array.get(kl_entry_price, i))

                if not has_setup
                    bool touching = (low <= range_top) and (high >= range_bottom)
                    if touching
                        array.set(trade_state, i, TE_STATE_ACTIVE)
                        // Evaluate trade filters
                        // Compute the imbalance ratio and total volume for this level
                        float ratio_i = array.get(kl_peak_ratio, i)
                        float totalVol = array.get(kl_poc_volume, i)
                        // Estimate opposing volume: for buy levels ratio = buy/sell, so sellVol ˜ totalVol/(1+ratio).
                        // For sell levels ratio = sell/buy, so buyVol ˜ totalVol/(1+ratio).
                        float opposingVol = totalVol / (1 + ratio_i)
                        float opposingPct = totalVol > 0 ? opposingVol / totalVol : 1.0
                        bool opposition_ok = opposingPct <= maxOpposingPct or ratio_i >= imbalanceRatio
                        bool trendAlign = not trendFilterEnabled or ((side == "buy" and trendDir == "up") or (side == "sell" and trendDir == "down"))
                        bool extremeLevel = ratio_i >= extremeRatio
                        // A level passes the filter if it aligns with the prevailing trend
                        // and either meets the opposing-volume threshold or already clears
                        // the baseline imbalance ratio. Extreme tiers still override both.
                        bool passFilter = not trendFilterEnabled or (trendAlign and (opposition_ok or extremeLevel)) or extremeLevel

                        if passFilter
                            // Use the unified swing+ATR stop and RR-banded targeting helper
                            bool created = create_trade_for_level(i)
                            if not created
                                array.set(kl_last_test_bar, i, bar_index)
                        else
                            // Filters not satisfied – remain ACTIVE and record touch
                            array.set(kl_last_test_bar, i, bar_index)
            
            // ENTRY ? TESTING (trade is live)
            else if current_state == STATE_ENTRY
                register_set_trade(i)
                float entry_band = bucket_size + (rejectionBuffer * syminfo.mintick)
                float entry_high = side == "buy" ? range_top + entry_band : range_bottom - entry_band
                float entry_low = side == "buy" ? range_bottom - entry_band : range_top + entry_band
                bool triggered = (low <= entry_high) and (high >= entry_low)
                bool broke_zone = side == "buy" ? (not na(array.get(kl_stop_price, i)) and close <= array.get(kl_stop_price, i)) : (not na(array.get(kl_stop_price, i)) and close >= array.get(kl_stop_price, i))

                if triggered
                    open_trade_for_level(i)
                    process_open_trade_bar(i, side, test_count, reject_count)
                else if broke_zone
                    reject_trade_for_level(i)

            // TESTING ? PROFIT or LOSS
            else if current_state == STATE_TESTING
                process_open_trade_bar(i, side, test_count, reject_count)

            // PROFIT ? HELD
            else if current_state == STATE_PROFIT
                if test_count >= 2
                    array.set(kl_state, i, STATE_HELD)

                // Check for retouch
                bool touching_again = (low <= range_top) and (high >= range_bottom)
                if touching_again and (bar_index > last_test + 3)
                    // Retouch entries share the same stop/target sizing as first touches
                    bool created = create_trade_for_level(i)
                    if not created
                        array.set(kl_last_test_bar, i, bar_index)

            // HELD
            else if current_state == STATE_HELD
                bool touching_again = (low <= range_top) and (high >= range_bottom)
                if touching_again and (bar_index > last_test + 3)
                    // Re-engage held levels with the unified trade creation rules
                    bool created = create_trade_for_level(i)
                    if not created
                        array.set(kl_last_test_bar, i, bar_index)

// ---------------------------------------------------------------------------
// Dev debug overlay for the most recent trade candidate
if barstate.islast
    if showDebug and array.size(trade_state) > 0
        int latest_idx = na
        for idx = array.size(trade_state) - 1 to 0
            int ts = array.get(trade_state, idx)
            if ts == TE_STATE_POSSIBLE or ts == TE_STATE_OPEN
                latest_idx := idx
                break

        if not na(latest_idx) and latest_idx < array.size(kl_entry_price) and latest_idx < array.size(kl_stop_price) and latest_idx < array.size(kl_target_price) and latest_idx < array.size(kl_rr_ratio) and latest_idx < array.size(kl_side)
            float entry = array.get(kl_entry_price, latest_idx)
            float stop = array.get(kl_stop_price, latest_idx)
            float target = array.get(kl_target_price, latest_idx)
            float rr = array.get(kl_rr_ratio, latest_idx)

            if not na(entry) and not na(stop) and not na(target) and not na(rr)
                int x1 = bar_index - 1
                int x2 = bar_index

                if na(debugEntryLine)
                    debugEntryLine := line.new(x1, entry, x2, entry, color=color.new(color.silver, 40), width=1, style=line.style_solid)
                else
                    line.set_xy1(debugEntryLine, x1, entry)
                    line.set_xy2(debugEntryLine, x2, entry)
                    line.set_color(debugEntryLine, color.new(color.silver, 40))

                if na(debugStopLine)
                    debugStopLine := line.new(x1, stop, x2, stop, color=color.new(col_stop, 20), width=1, style=line.style_solid)
                else
                    line.set_xy1(debugStopLine, x1, stop)
                    line.set_xy2(debugStopLine, x2, stop)
                    line.set_color(debugStopLine, color.new(col_stop, 20))

                if na(debugTargetLine)
                    debugTargetLine := line.new(x1, target, x2, target, color=color.new(col_target, 20), width=1, style=line.style_solid)
                else
                    line.set_xy1(debugTargetLine, x1, target)
                    line.set_xy2(debugTargetLine, x2, target)
                    line.set_color(debugTargetLine, color.new(col_target, 20))

                float riskTicks = math.round(math.abs(entry - stop) / syminfo.mintick * 10.0) / 10.0
                float rrRounded = math.round(rr * 10.0) / 10.0
                string side_val = array.get(kl_side, latest_idx)
                float levelTarget = find_next_target(latest_idx, side_val)
                string source = (not na(levelTarget) and math.abs(levelTarget - target) <= 0.5 * syminfo.mintick) ? "Level" : "Synthetic"

                if na(debugLabel)
                    debugLabel := label.new(bar_index, entry, "", color=color.new(color.gray, 85), textcolor=color.white, style=label.style_label_left, size=size.small)
                else
                    label.set_x(debugLabel, bar_index)
                    label.set_y(debugLabel, entry)

                label.set_text(debugLabel, "Risk: " + str.tostring(riskTicks) + "t\nRR: " + str.tostring(rrRounded) + " (" + source + ")")
            else
                if not na(debugEntryLine)
                    line.delete(debugEntryLine)
                    debugEntryLine := na
                if not na(debugStopLine)
                    line.delete(debugStopLine)
                    debugStopLine := na
                if not na(debugTargetLine)
                    line.delete(debugTargetLine)
                    debugTargetLine := na
                if not na(debugLabel)
                    label.delete(debugLabel)
                    debugLabel := na
        else
            if not na(debugEntryLine)
                line.delete(debugEntryLine)
                debugEntryLine := na
            if not na(debugStopLine)
                line.delete(debugStopLine)
                debugStopLine := na
            if not na(debugTargetLine)
                line.delete(debugTargetLine)
                debugTargetLine := na
            if not na(debugLabel)
                label.delete(debugLabel)
                debugLabel := na
    else
        if not na(debugEntryLine)
            line.delete(debugEntryLine)
            debugEntryLine := na
        if not na(debugStopLine)
            line.delete(debugStopLine)
            debugStopLine := na
        if not na(debugTargetLine)
            line.delete(debugTargetLine)
            debugTargetLine := na
        if not na(debugLabel)
            label.delete(debugLabel)
            debugLabel := na

// ============================================================================
// RENDERING - BOXES AND TRADE LINES
// ============================================================================

if array.size(kl_box) > 0
    for i = 0 to array.size(kl_box) - 1
        if i < array.size(kl_box) and i < array.size(kl_state)
            box current_box = array.get(kl_box, i)
            string state = array.get(kl_state, i)
            string side = array.get(kl_side, i)
            string tier = array.get(kl_tier, i)
            
            color base_color = side == "buy" ? col_buy : col_sell
            
            // Box rendering
            if showBoxes
                int base_opacity = 70
                if state == STATE_ACTIVE
                    base_opacity := 70
                else if state == STATE_ENTRY
                    base_opacity := 40  // Brighter - trade setup ready!
                else if state == STATE_TESTING
                    base_opacity := 50
                else if state == STATE_PROFIT
                    base_opacity := 30
                else if state == STATE_HELD
                    base_opacity := 20
                else
                    base_opacity := 90
                
                int tier_boost = tier == TIER_EXTREME ? 10 : tier == TIER_STRONG ? 5 : 0
                int final_opacity = math.max(10, base_opacity - tier_boost)
                
                box.set_right(current_box, bar_index + 1)
                box.set_border_color(current_box, color.new(base_color, final_opacity))
                box.set_bgcolor(current_box, color.new(base_color, final_opacity))
            
            // Trade line rendering
            if showTradeLines
                float entry = array.get(kl_entry_price, i)
                float stop = array.get(kl_stop_price, i)
                float target = array.get(kl_target_price, i)
                float rr = array.get(kl_rr_ratio, i)
                
                // Draw/update lines for ENTRY or TESTING states
                if (state == STATE_ENTRY or state == STATE_TESTING) and not na(entry) and not na(stop) and not na(target)
                    // Entry line
                    line entry_line = array.get(kl_entry_line, i)
                    if na(entry_line)
                        entry_line := line.new(bar_index, entry, bar_index + 1, entry, color = base_color, width = 2, style = line.style_solid)
                        array.set(kl_entry_line, i, entry_line)
                    else
                        line.set_x2(entry_line, bar_index + 1)

                    // Stop line
                    line stop_line = array.get(kl_stop_line, i)
                    if na(stop_line)
                        stop_line := line.new(bar_index, stop, bar_index + 1, stop, color = col_stop, width = 2, style = line.style_dashed)
                        array.set(kl_stop_line, i, stop_line)
                    else
                        line.set_x2(stop_line, bar_index + 1)

                    // Target line
                    line target_line = array.get(kl_target_line, i)
                    if na(target_line)
                        target_line := line.new(bar_index, target, bar_index + 1, target, color = col_target, width = 2, style = line.style_dotted)
                        array.set(kl_target_line, i, target_line)
                    else
                        line.set_x2(target_line, bar_index + 1)

                    // Label with RR
                    label trade_label = array.get(kl_trade_label, i)
                    if na(trade_label)
                        string label_text = str.tostring(rr, "#.#") + ":1"
                        trade_label := label.new(bar_index, entry, label_text, color = color.new(base_color, 80), textcolor = color.white, style = label.style_label_left, size = size.small)
                        array.set(kl_trade_label, i, trade_label)
                    else
                        label.set_x(trade_label, bar_index)
                
                // Add outcome marker for PROFIT
                else if state == STATE_PROFIT and not na(entry)
                    label trade_label = array.get(kl_trade_label, i)
                    if na(trade_label)
                        trade_label := label.new(bar_index, entry, "?", color = color.new(color.lime, 70), textcolor = color.white, style = label.style_label_up, size = size.normal)
                        array.set(kl_trade_label, i, trade_label)
                
                // Add outcome marker for LOSS
                else if state == STATE_LOSS and not na(entry)
                    label trade_label = array.get(kl_trade_label, i)
                    if na(trade_label)
                        trade_label := label.new(bar_index, entry, "?", color = color.new(color.red, 70), textcolor = color.white, style = label.style_label_down, size = size.normal)
                        array.set(kl_trade_label, i, trade_label)

                else if state == STATE_CLOSED
                    if i < array.size(kl_closed_logged) and not array.get(kl_closed_logged, i)
                        record_closed_trade(i)
                    line entry_line = array.get(kl_entry_line, i)
                    if not na(entry_line)
                        line.delete(entry_line)
                        array.set(kl_entry_line, i, na)
                    line stop_line = array.get(kl_stop_line, i)
                    if not na(stop_line)
                        line.delete(stop_line)
                        array.set(kl_stop_line, i, na)
                    line target_line = array.get(kl_target_line, i)
                    if not na(target_line)
                        line.delete(target_line)
                        array.set(kl_target_line, i, na)
                    label trade_label = array.get(kl_trade_label, i)
                    if na(trade_label) and not na(entry)
                        string marker = array.get(kl_outcome, i) == "Profit" ? "?" : "?"
                        trade_label := label.new(bar_index, entry, marker, color = color.new(color.gray, 75), textcolor = color.white, style = label.style_label_left, size = size.small)
                        array.set(kl_trade_label, i, trade_label)
                
                // Add outcome marker for REJECTED (never triggered)
                else if state == STATE_REJECTED and not na(entry)
                    label trade_label = array.get(kl_trade_label, i)
                    if na(trade_label)
                        trade_label := label.new(bar_index, entry, "R", color = color.new(color.gray, 70), textcolor = color.white, style = label.style_label_down, size = size.normal)
                        array.set(kl_trade_label, i, trade_label)

// Closed-trade visual overlays
if array.size(closed_trade_boxes) > 0
    color hidden_col = color.new(color.white, 100)
    for i = 0 to array.size(closed_trade_boxes) - 1
        box bx = array.get(closed_trade_boxes, i)
        color box_col = showClosedTradeBoxes ? color.new(color.white, closedTradeBoxOpacity) : hidden_col
        box.set_bgcolor(bx, box_col)
        box.set_border_color(bx, box_col)

f_clear(tbl) =>
    if table.is_valid(tbl)
        table.clear(tbl, 0, 0, table.columns(tbl) - 1, table.rows(tbl) - 1)

// ============================================================================
// TABLES
// ============================================================================

if not showTables
    f_clear(tbl_key)
    f_clear(tbl_trades)
    f_clear(tbl_flow)
    f_clear(tbl_mobile)
    f_clear(tbl_performance)
    continue


var table tbl_key = table.new(position=position.bottom_right, columns=9, rows=12, bgcolor=color.new(color.black, 80), border_width=1)
// Mobile-first ordering so the lightest tables reserve space before heavier layouts
var table tbl_mobile = table.new(position=mobileCompact ? position.bottom_center : position.bottom_center, columns=mobileCompact ? 3 : 4, rows=mobileCompact ? 8 : 16, bgcolor=color.new(color.black, 80), border_width=1)
// Reduce the trades table height to avoid overlap with the performance panel
var table tbl_trades = table.new(position=mobileCompact ? position.bottom_center : position.top_left, columns=mobileCompact ? 4 : 7, rows=mobileCompact ? 8 : 16, bgcolor=color.new(color.black, 80), border_width=1)
var table tbl_performance = table.new(position=mobileCompact ? position.bottom_right : position.bottom_left, columns=mobileCompact ? 4 : 6, rows=mobileCompact ? 12 : 20, bgcolor=color.new(color.black, 80), border_width=1)
var table tbl_flow = table.new(position=mobileCompact ? position.top_center : position.top_right, columns=mobileCompact ? 3 : 12, rows=mobileCompact ? 12 : 22, bgcolor=color.new(color.black, 80), border_width=1)

float closed_r_total = 0.0
int closed_r_trades = 0
int closed_r_wins = 0
int closed_rr_count = array.size(closed_trade_rr)
if closed_rr_count > 0
    for r_idx = 0 to closed_rr_count - 1
        float rr_val = array.get(closed_trade_rr, r_idx)
        if not na(rr_val)
            closed_r_total += rr_val
            closed_r_trades += 1
            if rr_val > 0
                closed_r_wins += 1
float closed_r_avg = closed_r_trades > 0 ? closed_r_total / closed_r_trades : na
float closed_r_winrate = closed_r_trades > 0 ? (closed_r_wins * 100.0) / closed_r_trades : na
float closed_tick_sum = 0.0
int closed_trade_count = array.size(closed_ticks)
int closed_tick_wins = 0
if closed_trade_count > 0
    for t_idx = 0 to closed_trade_count - 1
        float t_val = array.get(closed_ticks, t_idx)
        string res_val = t_idx < array.size(closed_result) ? array.get(closed_result, t_idx) : ""
        if not na(t_val)
            closed_tick_sum += t_val
        if res_val == "Profit" or (not na(t_val) and t_val > 0)
            closed_tick_wins += 1
float closed_tick_avg = closed_trade_count > 0 ? closed_tick_sum / closed_trade_count : na
float closed_tick_winrate = closed_trade_count > 0 ? (closed_tick_wins * 100.0) / closed_trade_count : na

if barstate.islast and not mobileCompact
    // Performance table for closed trades
    table.cell(tbl_performance, 0, 0, "PERFORMANCE (CLOSED TRADES)", text_color=color.white, text_size=size.normal, bgcolor=color.new(color.gray, 60))
    table.merge_cells(tbl_performance, 0, 0, 5, 0)

    int perf_row = 1
    table.cell(tbl_performance, 0, perf_row, "Trades", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 70))
    table.cell(tbl_performance, 1, perf_row, "Wins", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 70))
    table.cell(tbl_performance, 2, perf_row, "Win %", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 70))
    table.cell(tbl_performance, 3, perf_row, "PnL (tks)", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 70))
    table.cell(tbl_performance, 4, perf_row, "Avg Tks", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 70))
    table.cell(tbl_performance, 5, perf_row, "Avg R", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 70))

    perf_row += 1
    string win_pct = na(closed_tick_winrate) ? "na" : str.tostring(closed_tick_winrate, "#.0") + "%"
    string pnl_ticks = closed_trade_count > 0 ? str.tostring(math.round(closed_tick_sum), "+#;-#") : "na"
    string avg_ticks = na(closed_tick_avg) ? "na" : str.tostring(closed_tick_avg, "#.0")
    string avg_r = na(closed_r_avg) ? "na" : str.tostring(closed_r_avg, "#.0")
    table.cell(tbl_performance, 0, perf_row, str.tostring(closed_trade_count), text_color=color.white, text_size=size.small, bgcolor=color.new(color.black, 85))
    table.cell(tbl_performance, 1, perf_row, str.tostring(closed_tick_wins), text_color=color.white, text_size=size.small, bgcolor=color.new(color.black, 85))
    table.cell(tbl_performance, 2, perf_row, win_pct, text_color=color.white, text_size=size.small, bgcolor=color.new(color.black, 85))
    table.cell(tbl_performance, 3, perf_row, pnl_ticks, text_color=color.white, text_size=size.small, bgcolor=color.new(color.black, 85))
    table.cell(tbl_performance, 4, perf_row, avg_ticks, text_color=color.white, text_size=size.small, bgcolor=color.new(color.black, 85))
    table.cell(tbl_performance, 5, perf_row, avg_r, text_color=color.white, text_size=size.small, bgcolor=color.new(color.black, 85))

    perf_row += 2
    table.cell(tbl_performance, 0, perf_row, "CLOSED TRADES", text_color=color.white, text_size=size.normal, bgcolor=color.new(color.gray, 70))
    table.merge_cells(tbl_performance, 0, perf_row, 5, perf_row)

    perf_row += 1
    table.cell(tbl_performance, 0, perf_row, "Side", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 70))
    table.cell(tbl_performance, 1, perf_row, "Entry", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 70))
    table.cell(tbl_performance, 2, perf_row, "Exit", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 70))
    table.cell(tbl_performance, 3, perf_row, "Ticks", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 70))
    table.cell(tbl_performance, 4, perf_row, "R", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 70))
    table.cell(tbl_performance, 5, perf_row, "Result", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 70))

    int max_perf_rows = 10
    for row_idx = 0 to max_perf_rows - 1
        int data_row = perf_row + 1 + row_idx
        int rev_idx = array.size(closed_side) - 1 - row_idx
        bool has_trade = rev_idx >= 0
        color perf_bg = row_idx % 2 == 0 ? color.new(color.black, 90) : color.new(color.black, 80)
        if has_trade
            string s_side = array.get(closed_side, rev_idx)
            float e_entry = array.get(closed_entry, rev_idx)
            float exit_price = array.get(closed_result, rev_idx) == "Profit" ? array.get(closed_target, rev_idx) : array.get(closed_stop, rev_idx)
            float ticks_val = array.get(closed_ticks, rev_idx)
            float rr_val = array.get(closed_trade_rr, rev_idx)
            string result_val = array.get(closed_result, rev_idx)

            table.cell(tbl_performance, 0, data_row, s_side == "buy" ? "Buy" : "Sell", text_color=color.white, text_size=size.small, bgcolor=perf_bg)
            table.cell(tbl_performance, 1, data_row, str.tostring(e_entry, format.mintick), text_color=color.white, text_size=size.small, bgcolor=perf_bg)
            table.cell(tbl_performance, 2, data_row, str.tostring(exit_price, format.mintick), text_color=color.white, text_size=size.small, bgcolor=perf_bg)
            table.cell(tbl_performance, 3, data_row, str.tostring(ticks_val, "+#.0;-#.0"), text_color=color.white, text_size=size.small, bgcolor=perf_bg)
            table.cell(tbl_performance, 4, data_row, na(rr_val) ? "na" : str.tostring(rr_val, "#.0"), text_color=color.white, text_size=size.small, bgcolor=perf_bg)
            table.cell(tbl_performance, 5, data_row, result_val, text_color=color.white, text_size=size.small, bgcolor=perf_bg)
        else
            color empty_bg = color.new(color.gray, 95)
            for col = 0 to 5
                table.cell(tbl_performance, col, data_row, "-", text_color=color.gray, text_size=size.small, bgcolor=empty_bg)

    table.cell(tbl_key, 0, 0, "KEY IMBALANCE LEVELS", text_color=color.white, text_size=size.normal, bgcolor=color.new(color.gray, 50))
    table.merge_cells(tbl_key, 0, 0, 8, 0)
    
    table.cell(tbl_key, 0, 1, "Range", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 70))
    table.cell(tbl_key, 1, 1, "POC", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 70))
    table.cell(tbl_key, 2, 1, "Side", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 70))
    table.cell(tbl_key, 3, 1, "Peak", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 70))
    table.cell(tbl_key, 4, 1, "Tier", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 70))
    table.cell(tbl_key, 5, 1, "Score", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 70))
    table.cell(tbl_key, 6, 1, "Status", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 70))
    table.cell(tbl_key, 7, 1, "RR", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 70))
    table.cell(tbl_key, 8, 1, "Tests", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 70))
    
    int level_count = array.size(kl_poc)
    int display_count = math.min(level_count, 10)
    var int[] kl_price_order = array.new_int()
    var float[] kl_poc_buffer = array.new_float()
    array.clear(kl_price_order)
    array.clear(kl_poc_buffer)

    // Build a descending-by-price ordering so rows stack from high to low
    for i = 0 to level_count - 1
        array.push(kl_poc_buffer, array.get(kl_poc, i))
    for n = 0 to display_count - 1
        int best_pos = -1
        float best_val = na
        for j = 0 to level_count - 1
            float poc_val = array.get(kl_poc_buffer, j)
            if not na(poc_val) and (na(best_val) or poc_val > best_val)
                best_val := poc_val
                best_pos := j
        if best_pos >= 0
            array.push(kl_price_order, best_pos)
            array.set(kl_poc_buffer, best_pos, na)

    for row = 0 to 9
        int data_row = row + 2
        if row < display_count and row < array.size(kl_price_order)
            int level_idx = array.get(kl_price_order, row)
            float range_top = array.get(kl_range_top, level_idx)
            float range_bottom = array.get(kl_range_bottom, level_idx)
            float poc = array.get(kl_poc, level_idx)
            string side = array.get(kl_side, level_idx)
            float peak_ratio = array.get(kl_peak_ratio, level_idx)
            string tier = array.get(kl_tier, level_idx)
            float strength = array.get(kl_strength, level_idx)
            string state = array.get(kl_state, level_idx)
            int tests = array.get(kl_test_count, level_idx)
            float rr = array.get(kl_rr_ratio, level_idx)
            
            color side_color = side == "buy" ? col_buy : col_sell
            color tier_bg = tier == TIER_EXTREME ? color.new(color.orange, 92) : tier == TIER_STRONG ? color.new(color.blue, 92) : color.new(color.black, 90)
            
            color state_color = color.white
            color row_bg = tier_bg
            
            if state == STATE_HELD
                state_color := color.yellow
                row_bg := color.new(color.yellow, 90)
            else if state == STATE_PROFIT
                state_color := color.lime
                row_bg := color.new(color.lime, 90)
            else if state == STATE_ENTRY
                state_color := color.orange
                row_bg := color.new(color.orange, 90)
            else if state == STATE_TESTING
                state_color := color.aqua
            else if state == STATE_CLOSED
                state_color := color.silver
                row_bg := color.new(color.gray, 90)
            // Losing trades are highlighted in red
            else if state == STATE_LOSS
                state_color := color.red
                row_bg := color.new(color.red, 90)
            else if state == STATE_ACTIVE
                state_color := color.white
            // Rejected trades are grey
            else if state == STATE_REJECTED
                state_color := color.gray
                row_bg := color.new(color.gray, 92)
            else
                state_color := color.gray
            
            string range_str = str.tostring(range_bottom, format.mintick) + "-" + str.tostring(range_top, format.mintick)
            string rr_str = na(rr) ? "-" : str.tostring(rr, "#.#")
            
            table.cell(tbl_key, 0, data_row, range_str, text_color=color.white, text_size=size.small, bgcolor=row_bg)
            table.cell(tbl_key, 1, data_row, str.tostring(poc, format.mintick), text_color=side_color, text_size=size.small, bgcolor=row_bg)
            table.cell(tbl_key, 2, data_row, side == "buy" ? "?? B" : "?? S", text_color=side_color, text_size=size.small, bgcolor=row_bg)
            table.cell(tbl_key, 3, data_row, str.tostring(peak_ratio, "#.#") + ":1", text_color=side_color, text_size=size.small, bgcolor=row_bg)
            table.cell(tbl_key, 4, data_row, tier, text_color=color.yellow, text_size=size.small, bgcolor=row_bg)
            table.cell(tbl_key, 5, data_row, str.tostring(math.round(strength)), text_color=color.white, text_size=size.small, bgcolor=row_bg)
            // Map internal state to a user-friendly status for display.  ACTIVE
            // becomes blank (waiting), ENTRY becomes Ready, TESTING becomes
            // Live, PROFIT ? Profit, HELD ? Held, LOSS ? Loss, REJECTED ? Rejected.
            string display_state = ""
            if state == STATE_ENTRY
                display_state := "Ready"
            else if state == STATE_TESTING
                display_state := "Live"
            else if state == STATE_PROFIT
                display_state := "Profit"
            else if state == STATE_HELD
                display_state := "Held"
            else if state == STATE_CLOSED
                display_state := array.get(kl_outcome, row)
            else if state == STATE_LOSS
                display_state := "Loss"
            else if state == STATE_REJECTED
                display_state := "Rejected"
            else
                display_state := ""
            table.cell(tbl_key, 6, data_row, display_state, text_color=state_color, text_size=size.small, bgcolor=row_bg)
            table.cell(tbl_key, 7, data_row, rr_str, text_color=color.white, text_size=size.small, bgcolor=row_bg)
            table.cell(tbl_key, 8, data_row, str.tostring(tests), text_color=color.white, text_size=size.small, bgcolor=row_bg)
        else
            color empty_bg = color.new(color.gray, 95)
            for col = 0 to 8
                table.cell(tbl_key, col, data_row, "-", text_color=color.gray, text_size=size.small, bgcolor=empty_bg)

if barstate.islast and mobileCompact
    f_clear(tbl_flow)
    f_clear(tbl_mobile)
    f_clear(tbl_performance)

    color header_bg = color.new(color.gray, 40)
    color section_bg = color.new(color.gray, 70)

    table.cell(tbl_trades, 0, 0, "COMPACT TRADES", text_color=color.white, text_size=size.normal, bgcolor=header_bg)
    table.merge_cells(tbl_trades, 0, 0, 3, 0)

    int t_row = 1
    table.cell(tbl_trades, 0, t_row, "Dir", text_color=color.white, text_size=size.small, bgcolor=section_bg)
    table.cell(tbl_trades, 1, t_row, "Entry", text_color=color.white, text_size=size.small, bgcolor=section_bg)
    table.cell(tbl_trades, 2, t_row, "PnL (tks)", text_color=color.white, text_size=size.small, bgcolor=section_bg)
    table.cell(tbl_trades, 3, t_row, "RR", text_color=color.white, text_size=size.small, bgcolor=section_bg)
    t_row += 1

    int total_levels = array.size(kl_state)
    int max_rows = table.rows(tbl_trades) - 2
    float tick_size = syminfo.mintick

    for idx_offset = 0 to total_levels - 1
        int idx = total_levels - 1 - idx_offset
        if t_row - 2 < max_rows and idx < array.size(kl_state)
            string st = array.get(kl_state, idx)
            if st == STATE_ENTRY or st == STATE_TESTING
                string s_side = array.get(kl_side, idx)
                float e_entry = array.get(kl_entry_price, idx)
                float e_rr = array.get(kl_rr_ratio, idx)
                float pnl_ticks = na
                if st == STATE_TESTING and tick_size > 0
                    pnl_ticks := s_side == "buy" ? (close - e_entry) / tick_size : (e_entry - close) / tick_size
                string pnl_str = na(pnl_ticks) ? "-" : str.tostring(math.round(pnl_ticks), "+#;-#")
                color row_bg = s_side == "buy" ? color.new(col_buy, 90) : color.new(col_sell, 90)
                color dir_col = s_side == "buy" ? col_buy : col_sell
                table.cell(tbl_trades, 0, t_row, s_side == "buy" ? "Buy" : "Sell", text_color=dir_col, text_size=size.small, bgcolor=row_bg)
                table.cell(tbl_trades, 1, t_row, str.tostring(e_entry, format.mintick), text_color=color.white, text_size=size.small, bgcolor=row_bg)
                table.cell(tbl_trades, 2, t_row, pnl_str, text_color=color.white, text_size=size.small, bgcolor=row_bg)
                table.cell(tbl_trades, 3, t_row, na(e_rr) ? "-" : str.tostring(e_rr, "#.#"), text_color=color.white, text_size=size.small, bgcolor=row_bg)
                t_row += 1

    int last_row = table.rows(tbl_trades) - 1
    for r = t_row to last_row
        table.cell(tbl_trades, 0, r, "-", text_color=color.gray, text_size=size.small, bgcolor=color.new(color.gray, 95))
        table.cell(tbl_trades, 1, r, "-", text_color=color.gray, text_size=size.small, bgcolor=color.new(color.gray, 95))
        table.cell(tbl_trades, 2, r, "-", text_color=color.gray, text_size=size.small, bgcolor=color.new(color.gray, 95))
        table.cell(tbl_trades, 3, r, "-", text_color=color.gray, text_size=size.small, bgcolor=color.new(color.gray, 95))

if barstate.islast and not mobileCompact
    // ---------------------------------------------------------------------
    // Order flow table header and recent bars
    table.cell(tbl_flow, 0, 0, "ORDER FLOW HISTORY", text_color=color.white, text_size=size.normal, bgcolor=color.new(color.gray, 60))
    table.merge_cells(tbl_flow, 0, 0, 11, 0)

    int safe_bars = math.min(barsToShow, bar_index + 1)
    int current_row = 1

    for bar_idx = 0 to 2
        if bar_idx < safe_bars
            int col_start = bar_idx * 4
            int bar_offset = safe_bars - 1 - bar_idx
            string bar_label = "-" + str.tostring(bar_offset)
            table.cell(tbl_flow, col_start, current_row, bar_label, text_color=color.yellow, text_size=size.small, bgcolor=color.new(color.gray, 70))
            table.merge_cells(tbl_flow, col_start, current_row, col_start + 3, current_row)
    current_row += 1

    for bar_idx = 0 to 2
        if bar_idx < safe_bars
            int col_start = bar_idx * 4
            table.cell(tbl_flow, col_start + 0, current_row, "Price", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 75))
            table.cell(tbl_flow, col_start + 1, current_row, "B:S", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 75))
            table.cell(tbl_flow, col_start + 2, current_row, "?", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 75))
            table.cell(tbl_flow, col_start + 3, current_row, "??", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 75))
    current_row += 1

    for row = 0 to 7
        for bar_idx = 0 to 2
            if bar_idx < safe_bars
                int col_start = bar_idx * 4
                int bar_offset = safe_bars - 1 - bar_idx
                [prices, buys, sells] = calc_bar_levels(bar_offset)
                int level_count = array.size(prices)
                if level_count > 0 and row < level_count
                    int idx = level_count - 1 - row
                    float price = array.get(prices, idx)
                    float buy_vol = array.get(buys, idx)
                    float sell_vol = array.get(sells, idx)
                    float delta = buy_vol - sell_vol
                    float ratio = buy_vol >= sell_vol ? buy_vol / math.max(sell_vol, 1) : sell_vol / math.max(buy_vol, 1)
                    bool is_imbalance = ratio >= imbalanceRatio
                    color row_bg = is_imbalance ? (buy_vol > sell_vol ? color.new(col_buy, 85) : color.new(col_sell, 85)) : color.new(color.black, 92)
                    table.cell(tbl_flow, col_start + 0, current_row, str.tostring(price, format.mintick), text_color=color.white, text_size=size.small, bgcolor=row_bg)
                    table.cell(tbl_flow, col_start + 1, current_row, str.tostring(math.round(buy_vol)) + ":" + str.tostring(math.round(sell_vol)), text_color=color.white, text_size=size.small, bgcolor=row_bg)
                    table.cell(tbl_flow, col_start + 2, current_row, str.tostring(math.round(delta), "+#;-#"), text_color=delta > 0 ? col_buy : col_sell, text_size=size.small, bgcolor=row_bg)
                    table.cell(tbl_flow, col_start + 3, current_row, is_imbalance ? "??" : "", text_color=color.orange, text_size=size.small, bgcolor=row_bg)
                else
                    color empty_bg = color.new(color.gray, 95)
                    table.cell(tbl_flow, col_start + 0, current_row, "-", text_color=color.gray, text_size=size.small, bgcolor=empty_bg)
                    table.cell(tbl_flow, col_start + 1, current_row, "-", text_color=color.gray, text_size=size.small, bgcolor=empty_bg)
                    table.cell(tbl_flow, col_start + 2, current_row, "-", text_color=color.gray, text_size=size.small, bgcolor=empty_bg)
                    table.cell(tbl_flow, col_start + 3, current_row, "", bgcolor=empty_bg)
        current_row += 1

    // ---------------------------------------------------------------------
    // Unified trades table showing possible (ENTRY) and open (TESTING) trades only.
    int total_levels = array.size(kl_state)
    // Use a smaller number of rows to shorten the trades table and reduce overlap with other tables
    int trades_rows = mobileCompact ? 12 : 16
    int last_trade_row = trades_rows - 1

    // Ensure any closed trades are logged before rendering so winners/losses always appear
    if array.size(trade_state) > 0 and array.size(kl_closed_logged) > 0
        for idx = 0 to array.size(trade_state) - 1
            int ts_closed = array.get(trade_state, idx)
            bool is_closed = ts_closed == TE_STATE_CLOSED_WIN or ts_closed == TE_STATE_CLOSED_LOSS
            bool opened_once = idx < array.size(trade_opened) ? array.get(trade_opened, idx) : false
            bool already_closed = idx < array.size(trade_closed_bar) and not na(array.get(trade_closed_bar, idx))
            if is_closed and opened_once and not already_closed and idx < array.size(kl_closed_logged) and not array.get(kl_closed_logged, idx)
                record_closed_trade(idx)

    // Table title
    table.cell(tbl_trades, 0, 0, "TRADES", text_color=color.white, text_size=size.normal, bgcolor=color.new(color.gray, 60))
    table.merge_cells(tbl_trades, 0, 0, 6, 0)

    // Possible and live trades section
    int t_row = 1
    table.cell(tbl_trades, 0, t_row, "SET / OPEN TRADES", text_color=color.white, text_size=size.normal, bgcolor=color.new(color.gray, 70))
    table.merge_cells(tbl_trades, 0, t_row, 6, t_row)
    t_row += 1
    table.cell(tbl_trades, 0, t_row, "Side", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 70))
    table.cell(tbl_trades, 1, t_row, "Entry", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 70))
    table.cell(tbl_trades, 2, t_row, "Stop", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 70))
    table.cell(tbl_trades, 3, t_row, "Target", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 70))
    table.cell(tbl_trades, 4, t_row, "RR", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 70))
    table.cell(tbl_trades, 5, t_row, "Tier", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 70))
    table.cell(tbl_trades, 6, t_row, "Status", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 70))
    t_row += 1

    int max_p = 8
    for idx_offset = 0 to total_levels - 1
        int idx = total_levels - 1 - idx_offset
        if idx < array.size(kl_state) and t_row < max_p + 3
            string st = array.get(kl_state, idx)
            if st == STATE_ENTRY or st == STATE_TESTING
                string s_side = array.get(kl_side, idx)
                float e_entry = array.get(kl_entry_price, idx)
                float e_stop = array.get(kl_stop_price, idx)
                float e_target = array.get(kl_target_price, idx)
                float e_rr = array.get(kl_rr_ratio, idx)
                string e_tier = array.get(kl_tier, idx)
                string side_str = s_side == "buy" ? "Buy" : "Sell"
                string rr_str = na(e_rr) ? "-" : str.tostring(e_rr, "#.#")
                string status_str = st == STATE_TESTING ? "Live" : "Ready"
                color row_bg = s_side == "buy" ? color.new(col_buy, 90) : color.new(col_sell, 90)
                color side_color2 = s_side == "buy" ? col_buy : col_sell
                table.cell(tbl_trades, 0, t_row, side_str, text_color=side_color2, text_size=size.small, bgcolor=row_bg)
                table.cell(tbl_trades, 1, t_row, str.tostring(e_entry, format.mintick), text_color=color.white, text_size=size.small, bgcolor=row_bg)
                table.cell(tbl_trades, 2, t_row, str.tostring(e_stop, format.mintick), text_color=color.white, text_size=size.small, bgcolor=row_bg)
                table.cell(tbl_trades, 3, t_row, str.tostring(e_target, format.mintick), text_color=color.white, text_size=size.small, bgcolor=row_bg)
                table.cell(tbl_trades, 4, t_row, rr_str, text_color=color.white, text_size=size.small, bgcolor=row_bg)
                table.cell(tbl_trades, 5, t_row, e_tier, text_color=color.yellow, text_size=size.small, bgcolor=row_bg)
                table.cell(tbl_trades, 6, t_row, status_str, text_color=color.white, text_size=size.small, bgcolor=row_bg)
                t_row += 1
    int possible_fill_end = math.min(max_p + 2, last_trade_row)
    for r = t_row to possible_fill_end
        for c = 0 to 6
            table.cell(tbl_trades, c, r, "-", text_color=color.gray, text_size=size.small, bgcolor=color.new(color.gray, 95))
    int fill_start_row = math.min(possible_fill_end + 1, last_trade_row)
    for r = fill_start_row to last_trade_row
        for col = 0 to 6
            table.cell(tbl_trades, col, r, "-", text_color=color.gray, text_size=size.small, bgcolor=color.new(color.gray, 95))
    
    table.cell(tbl_flow, 0, current_row, "", bgcolor=color.new(color.gray, 80))
    table.merge_cells(tbl_flow, 0, current_row, 11, current_row)
    current_row += 1
    
    for bar_idx = 0 to 2
        int actual_bar_idx = bar_idx + 3
        if actual_bar_idx < safe_bars
            int col_start = bar_idx * 4
            int bar_offset = safe_bars - 1 - actual_bar_idx
            string bar_label = bar_offset == 0 ? "NOW" : "-" + str.tostring(bar_offset)
            table.cell(tbl_flow, col_start, current_row, bar_label, text_color=bar_offset == 0 ? color.lime : color.yellow, text_size=size.small, bgcolor=color.new(color.gray, 70))
            table.merge_cells(tbl_flow, col_start, current_row, col_start + 3, current_row)
    current_row += 1
    
    for bar_idx = 0 to 2
        int actual_bar_idx = bar_idx + 3
        if actual_bar_idx < safe_bars
            int col_start = bar_idx * 4
            table.cell(tbl_flow, col_start + 0, current_row, "Price", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 75))
            table.cell(tbl_flow, col_start + 1, current_row, "B:S", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 75))
            table.cell(tbl_flow, col_start + 2, current_row, "?", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 75))
            table.cell(tbl_flow, col_start + 3, current_row, "??", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 75))
    current_row += 1
    
    for row = 0 to 7
        for bar_idx = 0 to 2
            int actual_bar_idx = bar_idx + 3
            if actual_bar_idx < safe_bars
                int col_start = bar_idx * 4
                int bar_offset = safe_bars - 1 - actual_bar_idx
                [prices, buys, sells] = calc_bar_levels(bar_offset)
                int level_count = array.size(prices)
                if level_count > 0 and row < level_count
                    int idx = level_count - 1 - row
                    float price = array.get(prices, idx)
                    float buy_vol = array.get(buys, idx)
                    float sell_vol = array.get(sells, idx)
                    float delta = buy_vol - sell_vol
                    float ratio = buy_vol >= sell_vol ? buy_vol / math.max(sell_vol, 1) : sell_vol / math.max(buy_vol, 1)
                    bool is_imbalance = ratio >= imbalanceRatio
                    color row_bg = is_imbalance ? (buy_vol > sell_vol ? color.new(col_buy, 85) : color.new(col_sell, 85)) : color.new(color.black, 92)
                    table.cell(tbl_flow, col_start + 0, current_row, str.tostring(price, format.mintick), text_color=color.white, text_size=size.small, bgcolor=row_bg)
                    table.cell(tbl_flow, col_start + 1, current_row, str.tostring(math.round(buy_vol)) + ":" + str.tostring(math.round(sell_vol)), text_color=color.white, text_size=size.small, bgcolor=row_bg)
                    table.cell(tbl_flow, col_start + 2, current_row, str.tostring(math.round(delta), "+#;-#"), text_color=delta > 0 ? col_buy : col_sell, text_size=size.small, bgcolor=row_bg)
                    table.cell(tbl_flow, col_start + 3, current_row, is_imbalance ? "??" : "", text_color=color.orange, text_size=size.small, bgcolor=row_bg)
                else
                    color empty_bg = color.new(color.gray, 95)
                    table.cell(tbl_flow, col_start + 0, current_row, "-", text_color=color.gray, text_size=size.small, bgcolor=empty_bg)
                    table.cell(tbl_flow, col_start + 1, current_row, "-", text_color=color.gray, text_size=size.small, bgcolor=empty_bg)
                    table.cell(tbl_flow, col_start + 2, current_row, "-", text_color=color.gray, text_size=size.small, bgcolor=empty_bg)
                    table.cell(tbl_flow, col_start + 3, current_row, "", bgcolor=empty_bg)
        current_row += 1
 
                                                        
