//@version=6
indicator("LarsTrades Order Flow", overlay=true, max_boxes_count=50, max_labels_count=50)

// ==================== INPUTS ====================
grp1 = "Order Flow Table"
show_table = input.bool(true, "Show Table", group=grp1)
lookback = input.int(6, "Bars to Analyze", minval=1, maxval=20, group=grp1)
levels = input.int(5, "Levels per Bar", minval=2, maxval=10, group=grp1)

grp2 = "Order Blocks"
show_blocks = input.bool(true, "Show Order Blocks", group=grp2)
ob_ratio = input.float(4.0, "Min Ratio for Block", minval=3.0, step=0.5, group=grp2, tooltip="Higher = fewer, stronger blocks")
ob_vol_mult = input.float(1.5, "Min Volume Multiplier", minval=1.0, step=0.1, group=grp2, tooltip="Volume must be X times average")
max_active_blocks = input.int(5, "Max Active Blocks", minval=2, maxval=10, group=grp2)
min_price_gap = input.float(2.0, "Min Points Between Blocks", minval=0.5, step=0.5, group=grp2, tooltip="Gap used to flag stacked blocks")
ob_lifespan = input.int(200, "Bars to Keep Unfilled Blocks", minval=10, maxval=500, group=grp2)

grp2b = "Trade Cues"
show_trades = input.bool(true, "Show Trade Markers", group=grp2b, tooltip="Plot entry/stop/targets after retest or fill")
tp_rr1 = input.float(1.0, "TP1 Reward:Risk", minval=0.5, maxval=3.0, step=0.25, group=grp2b)
tp_rr2 = input.float(2.0, "TP2 Reward:Risk", minval=1.0, maxval=6.0, step=0.25, group=grp2b)

grp3 = "Colors"
col_buy = input.color(#00ff41, "Buy (Green)", group=grp3)
col_sell = input.color(#b968ff, "Sell (Purple)", group=grp3)
col_accent = input.color(#ffeb3b, "Accent (Yellow)", group=grp3)

grp4 = "Alerts"
alert_new_blocks = input.bool(true, "Alert on New Blocks", group=grp4)
alert_filled_blocks = input.bool(true, "Alert on Filled Blocks", group=grp4)
alert_retest_blocks = input.bool(true, "Alert on Retest", group=grp4)

// ==================== CALCULATIONS ====================
avg_vol = ta.sma(volume, 20)

// ==================== ALERT STATE ====================
new_block_trigger = false
filled_block_trigger = false
retest_block_trigger = false
new_block_message = ""
filled_block_message = ""
retest_block_message = ""

// ==================== ORDER BLOCK STORAGE ====================
var box[] ob_boxes = array.new_box()
var label[] ob_labels = array.new_label()
var float[] ob_prices = array.new_float()  // Mid price for gap checking
var float[] ob_tops = array.new_float()
var float[] ob_bots = array.new_float()
var string[] ob_sides = array.new_string()
var int[] ob_bars = array.new_int()
var bool[] ob_active = array.new_bool()
var float[] ob_ratios = array.new_float()
var float[] ob_strengths = array.new_float()
var bool[] ob_retested = array.new_bool()
var bool[] ob_stacked = array.new_bool()
var string[] ob_states = array.new_string()  // active, filled, expired

// Trade marker storage aligned with block indices
var label[] ob_trade_entry = array.new_label()
var label[] ob_trade_tp1 = array.new_label()
var label[] ob_trade_tp2 = array.new_label()
var label[] ob_trade_stop = array.new_label()

// ==================== AGGRESSIVE RATIO CALCULATION ====================
calc_level_ratio(float lvl_mid, float h, float l, float o, float c, float v, float rng) =>
    body = math.abs(c - o)
    body_pct = body / rng
    upper_wick = h - math.max(o, c)
    lower_wick = math.min(o, c) - l
    
    buy_pct = 0.5
    
    if c > o  // Bullish
        buy_pct := 0.55 + (body_pct * 0.40)
        if lower_wick > 0
            wick_ratio = lower_wick / rng
            buy_pct := buy_pct + (wick_ratio * 0.20)
        if upper_wick > 0
            wick_ratio = upper_wick / rng
            buy_pct := buy_pct - (wick_ratio * 0.10)
    else  // Bearish
        buy_pct := 0.45 - (body_pct * 0.40)
        if upper_wick > 0
            wick_ratio = upper_wick / rng
            buy_pct := buy_pct - (wick_ratio * 0.20)
        if lower_wick > 0
            wick_ratio = lower_wick / rng
            buy_pct := buy_pct + (wick_ratio * 0.10)
    
    // Position adjustment
    pos = (lvl_mid - l) / rng
    if c > o
        if pos > 0.7
            buy_pct := buy_pct * 1.3
        else if pos < 0.3
            buy_pct := buy_pct * 0.7
    else
        if pos < 0.3
            buy_pct := buy_pct * 0.65
        else if pos > 0.7
            buy_pct := buy_pct * 1.25
    
    buy_pct := math.max(0.05, math.min(0.95, buy_pct))
    sell_pct = 1.0 - buy_pct
    
    ratio = buy_pct > sell_pct ? buy_pct / sell_pct : sell_pct / buy_pct
    is_buy = buy_pct > sell_pct

    [ratio, is_buy, buy_pct]

// ==================== ACTIVE META LOOKUP ====================
// Helper to flag if a standout level lines up with an active block
active_meta(float price) =>
    near_block = false
    near_stacked = false
    near_retest = false
    float near_strength = 0.0
    near_side = ""
    if array.size(ob_active) > 0
        for i = 0 to array.size(ob_active) - 1
            if array.get(ob_active, i)
                if math.abs(price - array.get(ob_prices, i)) < (min_price_gap / 2)
                    near_block := true
                    near_stacked := array.get(ob_stacked, i)
                    near_retest := array.get(ob_retested, i)
                    near_strength := array.get(ob_strengths, i)
                    near_side := array.get(ob_sides, i)
                    break
    [near_block, near_stacked, near_retest, near_strength, near_side]

// ==================== PROCESS BARS ====================
if barstate.isconfirmed and volume > 0 and (high - low) > 0
    rng = high - low
    step = rng / levels
    // Find the BEST level in this candle (highest ratio)
    best_ratio = 0.0
    best_is_buy = false
    best_buy_pct = 0.5
    best_lvl_top = 0.0
    best_lvl_bot = 0.0
    best_lvl_mid = 0.0
    
    for i = 0 to levels - 1
        lvl_bot = low + (i * step)
        lvl_top = lvl_bot + step
        lvl_mid = (lvl_bot + lvl_top) / 2
        
        [ratio, is_buy, buy_pct] = calc_level_ratio(lvl_mid, high, low, open, close, volume, rng)
        
        if ratio > best_ratio
            best_ratio := ratio
            best_is_buy := is_buy
            best_buy_pct := buy_pct
            best_lvl_top := lvl_top
            best_lvl_bot := lvl_bot
            best_lvl_mid := lvl_mid

    // Only create ONE block per candle, and only if it qualifies
    vol_qualified = volume >= (avg_vol * ob_vol_mult) or best_ratio >= ob_ratio + 1.0
    if show_blocks and best_ratio >= ob_ratio and vol_qualified
        // Count active blocks
        active_count = 0
        if array.size(ob_active) > 0
            for j = 0 to array.size(ob_active) - 1
                if array.get(ob_active, j)
                    active_count += 1
        
        can_add = active_count < max_active_blocks
        
        // If at limit, replace weakest
        if not can_add and array.size(ob_ratios) > 0
            min_ratio = best_ratio
            min_idx = -1
            for j = 0 to array.size(ob_ratios) - 1
                if array.get(ob_active, j)
                    if array.get(ob_ratios, j) < min_ratio
                        min_ratio := array.get(ob_ratios, j)
                        min_idx := j
            
            if min_idx >= 0
                array.set(ob_active, min_idx, false)
                box.delete(array.get(ob_boxes, min_idx))
                label.delete(array.get(ob_labels, min_idx))
                can_add := true
        
        if can_add
            box_bg = best_is_buy ? color.new(col_buy, 75) : color.new(col_sell, 75)
            box_border = best_is_buy ? col_buy : col_sell

            // Derive strength score that blends ratio and relative volume at the level
            vol_at_lvl = volume / levels
            vol_factor = avg_vol > 0 ? vol_at_lvl / avg_vol : 1
            strength = best_ratio * vol_factor

            // Check for stacking with existing blocks of the same side (close price or consecutive bars)
            is_stacked = false
            if array.size(ob_active) > 0
                for i = 0 to array.size(ob_active) - 1
                    if array.get(ob_active, i) and array.get(ob_sides, i) == (best_is_buy ? "buy" : "sell")
                        if math.abs(best_lvl_mid - array.get(ob_prices, i)) <= min_price_gap or bar_index - array.get(ob_bars, i) <= 1
                            is_stacked := true
                            array.set(ob_stacked, i, true)
                            break

            new_box = box.new(bar_index, best_lvl_top, bar_index + 200, best_lvl_bot, bgcolor=box_bg, border_color=box_border, border_width=2)
            array.push(ob_boxes, new_box)
            
            lbl_txt = (best_is_buy ? "BUY " : "SELL ") + str.tostring(best_ratio, "#.#") + ":1"
            lbl_y = best_is_buy ? best_lvl_top : best_lvl_bot
            lbl_style = best_is_buy ? label.style_label_lower_left : label.style_label_upper_left
            new_lbl = label.new(bar_index, lbl_y, lbl_txt, color=color.new(box_border, 20), textcolor=color.white, style=lbl_style, size=size.normal)
            array.push(ob_labels, new_lbl)
            
            array.push(ob_prices, best_lvl_mid)
            array.push(ob_tops, best_lvl_top)
            array.push(ob_bots, best_lvl_bot)
            array.push(ob_sides, best_is_buy ? "buy" : "sell")
            array.push(ob_bars, bar_index)
            array.push(ob_active, true)
            array.push(ob_ratios, best_ratio)
            array.push(ob_strengths, strength)
            array.push(ob_retested, false)
            array.push(ob_stacked, is_stacked)
            array.push(ob_states, "active")
            array.push(ob_trade_entry, na)
            array.push(ob_trade_tp1, na)
            array.push(ob_trade_tp2, na)
            array.push(ob_trade_stop, na)

            new_block_trigger := true
            new_block_message := (best_is_buy ? "New BUY imbalance " : "New SELL imbalance ") +
                 "at " + str.tostring(best_lvl_mid, format.mintick) + " (" + str.tostring(best_ratio, "#.#") + ":1)"

// ==================== UPDATE ORDER BLOCKS ====================
if array.size(ob_boxes) > 0
    for i = array.size(ob_boxes) - 1 to 0
        if i >= 0 and i < array.size(ob_active)
            if array.get(ob_active, i)
                top_price = array.get(ob_tops, i)
                bot_price = array.get(ob_bots, i)
                side = array.get(ob_sides, i)
                start_bar = array.get(ob_bars, i)
                stacked = array.get(ob_stacked, i)
                already_retested = array.get(ob_retested, i)

                if bar_index > start_bar
                    filled = false
                    if side == "buy" and low < bot_price
                        filled := true
                    if side == "sell" and high > top_price
                        filled := true

                    // Detect retest without full fill
                    retest = false
                    if not filled
                        if side == "buy" and low <= top_price and low >= bot_price
                            retest := true
                        if side == "sell" and high >= bot_price and high <= top_price
                            retest := true

                    // Expire if it has stayed open too long
                    expired = not filled and (bar_index - start_bar > ob_lifespan)

                    if filled or expired
                        array.set(ob_active, i, false)
                        box.set_bgcolor(array.get(ob_boxes, i), color.new(color.gray, 90))
                        box.set_border_color(array.get(ob_boxes, i), color.new(color.gray, 70))
                        box.set_right(array.get(ob_boxes, i), bar_index)
                        label.delete(array.get(ob_labels, i))
                        if show_trades
                            entry_lbl = array.get(ob_trade_entry, i)
                            stop_lbl = array.get(ob_trade_stop, i)
                            tp1_lbl = array.get(ob_trade_tp1, i)
                            tp2_lbl = array.get(ob_trade_tp2, i)
                            done_txt = expired ? "Expired" : "Filled"
                            if not na(entry_lbl)
                                label.set_text(entry_lbl, "Entry " + done_txt)
                                label.set_color(entry_lbl, color.new(color.gray, 70))
                                label.set_textcolor(entry_lbl, color.gray)
                            if not na(stop_lbl)
                                label.set_text(stop_lbl, "Stop " + done_txt)
                                label.set_color(stop_lbl, color.new(color.gray, 70))
                                label.set_textcolor(stop_lbl, color.gray)
                            if not na(tp1_lbl)
                                label.set_text(tp1_lbl, "TP1 " + done_txt)
                                label.set_color(tp1_lbl, color.new(color.gray, 70))
                                label.set_textcolor(tp1_lbl, color.gray)
                            if not na(tp2_lbl)
                                label.set_text(tp2_lbl, "TP2 " + done_txt)
                                label.set_color(tp2_lbl, color.new(color.gray, 70))
                                label.set_textcolor(tp2_lbl, color.gray)
                        array.set(ob_states, i, filled ? "filled" : "expired")
                        if filled
                            filled_block_trigger := true
                            mid_price = (top_price + bot_price) / 2
                            filled_block_message := (side == "buy" ? "BUY" : "SELL") + " imbalance filled at " +
                                 str.tostring(mid_price, format.mintick)
                    else
                        // Keep extending active blocks forward
                        box.set_right(array.get(ob_boxes, i), bar_index + 30)
                        array.set(ob_states, i, "active")
                        if retest and not already_retested
                            array.set(ob_retested, i, true)
                            retest_block_trigger := true
                            mid_price = (top_price + bot_price) / 2
                            retest_block_message := (side == "buy" ? "BUY" : "SELL") + " imbalance retested at " +
                                 str.tostring(mid_price, format.mintick)
                            already_retested := true

                        // Create or refresh trade markers after a retest
                        if show_trades
                            entry_price = (top_price + bot_price) / 2
                            stop_price = side == "buy" ? bot_price - syminfo.mintick : top_price + syminfo.mintick
                            risk = math.max(math.abs(entry_price - stop_price), syminfo.mintick)
                            tp1 = side == "buy" ? entry_price + (risk * tp_rr1) : entry_price - (risk * tp_rr1)
                            tp2 = side == "buy" ? entry_price + (risk * tp_rr2) : entry_price - (risk * tp_rr2)
                            side_col = side == "buy" ? col_buy : col_sell

                            entry_lbl = array.get(ob_trade_entry, i)
                            stop_lbl = array.get(ob_trade_stop, i)
                            tp1_lbl = array.get(ob_trade_tp1, i)
                            tp2_lbl = array.get(ob_trade_tp2, i)

                            if retest and na(entry_lbl)
                                entry_lbl := label.new(bar_index, entry_price, "Entry", color=color.new(color.black, 0), textcolor=side_col, style=label.style_label_left, size=size.tiny)
                                stop_lbl := label.new(bar_index, stop_price, "Stop", color=color.new(color.red, 10), textcolor=color.red, style=label.style_label_left, size=size.tiny)
                                tp1_lbl := label.new(bar_index, tp1, "TP1", color=color.new(side_col, 30), textcolor=side_col, style=label.style_label_left, size=size.tiny)
                                tp2_lbl := label.new(bar_index, tp2, "TP2", color=color.new(side_col, 15), textcolor=side_col, style=label.style_label_left, size=size.tiny)
                                array.set(ob_trade_entry, i, entry_lbl)
                                array.set(ob_trade_stop, i, stop_lbl)
                                array.set(ob_trade_tp1, i, tp1_lbl)
                                array.set(ob_trade_tp2, i, tp2_lbl)
                            else if not na(entry_lbl)
                                label.set_x(entry_lbl, bar_index)
                                label.set_y(entry_lbl, entry_price)
                                if not na(stop_lbl)
                                    label.set_x(stop_lbl, bar_index)
                                    label.set_y(stop_lbl, stop_price)
                                if not na(tp1_lbl)
                                    label.set_x(tp1_lbl, bar_index)
                                    label.set_y(tp1_lbl, tp1)
                                if not na(tp2_lbl)
                                    label.set_x(tp2_lbl, bar_index)
                                    label.set_y(tp2_lbl, tp2)

                        // Update visuals for active state, stacking, and retests
                        base_border = side == "buy" ? col_buy : col_sell
                        border_col = retest or already_retested ? col_accent : base_border
                        border_w = stacked or retest or already_retested ? 3 : 2
                        bg_col = side == "buy" ? color.new(col_buy, stacked ? 65 : 75) : color.new(col_sell, stacked ? 65 : 75)
                        box.set_border_color(array.get(ob_boxes, i), border_col)
                        box.set_border_width(array.get(ob_boxes, i), border_w)
                        box.set_bgcolor(array.get(ob_boxes, i), bg_col)

                        lbl_txt = (side == "buy" ? "BUY " : "SELL ") + str.tostring(array.get(ob_ratios, i), "#.#") + ":1"
                        if stacked
                            lbl_txt := lbl_txt + " â§‰"
                        if retest or already_retested
                            lbl_txt := lbl_txt + " â†º"
                        lbl_y = side == "buy" ? top_price : bot_price
                        lbl_style = side == "buy" ? label.style_label_lower_left : label.style_label_upper_left
                        label.set_text(array.get(ob_labels, i), lbl_txt)
                        label.set_color(array.get(ob_labels, i), color.new(border_col, 20))
                        label.set_textcolor(array.get(ob_labels, i), color.white)
                        label.set_style(array.get(ob_labels, i), lbl_style)
                        label.set_x(array.get(ob_labels, i), bar_index)
                        label.set_y(array.get(ob_labels, i), lbl_y)
            
            // Remove old blocks
            if not array.get(ob_active, i) and bar_index - array.get(ob_bars, i) > 100
                box.delete(array.get(ob_boxes, i))
                array.remove(ob_boxes, i)
                array.remove(ob_labels, i)
                array.remove(ob_prices, i)
                array.remove(ob_tops, i)
                array.remove(ob_bots, i)
                array.remove(ob_sides, i)
                array.remove(ob_bars, i)
                array.remove(ob_active, i)
                array.remove(ob_ratios, i)
                array.remove(ob_strengths, i)
                array.remove(ob_retested, i)
                array.remove(ob_stacked, i)
                array.remove(ob_states, i)
                if i < array.size(ob_trade_entry)
                    if not na(array.get(ob_trade_entry, i))
                        label.delete(array.get(ob_trade_entry, i))
                    if not na(array.get(ob_trade_stop, i))
                        label.delete(array.get(ob_trade_stop, i))
                    if not na(array.get(ob_trade_tp1, i))
                        label.delete(array.get(ob_trade_tp1, i))
                    if not na(array.get(ob_trade_tp2, i))
                        label.delete(array.get(ob_trade_tp2, i))
                    array.remove(ob_trade_entry, i)
                    array.remove(ob_trade_stop, i)
                    array.remove(ob_trade_tp1, i)
                    array.remove(ob_trade_tp2, i)

// ==================== ALERTS ====================
// Pine requires a const string for the alertcondition message; per-event details are sent via alert() below
alertcondition(alert_new_blocks and new_block_trigger, "New imbalance zone", "New imbalance zone")
alertcondition(alert_retest_blocks and retest_block_trigger, "Imbalance retested", "Imbalance retested")
alertcondition(alert_filled_blocks and filled_block_trigger, "Imbalance filled", "Imbalance filled")

if barstate.isconfirmed
    if alert_new_blocks and new_block_trigger and str.length(new_block_message) > 0
        alert(new_block_message, alert.freq_once_per_bar_close)
    if alert_retest_blocks and retest_block_trigger and str.length(retest_block_message) > 0
        alert(retest_block_message, alert.freq_once_per_bar_close)
    if alert_filled_blocks and filled_block_trigger and str.length(filled_block_message) > 0
        alert(filled_block_message, alert.freq_once_per_bar_close)

// ==================== TABLES ====================
var table main_tbl = table.new(position.middle_right, 7, 18, bgcolor=color.new(color.black, 10), frame_color=col_accent, frame_width=2, border_width=1, border_color=color.new(color.gray, 60))

var lvl_prices = array.new_float()
var lvl_buys = array.new_float()
var lvl_sells = array.new_float()
var lvl_ratios = array.new_float()
var lvl_is_buy = array.new_bool()
var lvl_scores = array.new_float()
var lvl_bars = array.new_int()

if barstate.islast and show_table
    // ========== COLLECT ORDER FLOW LEVELS ==========
    array.clear(lvl_prices)
    array.clear(lvl_buys)
    array.clear(lvl_sells)
    array.clear(lvl_ratios)
    array.clear(lvl_is_buy)
    array.clear(lvl_scores)
    array.clear(lvl_bars)

    for b = 0 to lookback - 1
        if volume[b] > 0 and (high[b] - low[b]) > 0
            rng = high[b] - low[b]
            step = rng / levels

            for j = 0 to levels - 1
                lvl_bot = low[b] + (j * step)
                lvl_mid = lvl_bot + (step / 2)

                [ratio, is_buy, buy_pct] = calc_level_ratio(lvl_mid, high[b], low[b], open[b], close[b], volume[b], rng)

                vol_at_lvl = volume[b] / levels
                bv = vol_at_lvl * buy_pct
                sv = vol_at_lvl * (1 - buy_pct)
                score = ratio * (avg_vol > 0 ? (vol_at_lvl / avg_vol) : 1)

                if ratio >= 2.0
                    array.push(lvl_prices, lvl_mid)
                    array.push(lvl_buys, bv)
                    array.push(lvl_sells, sv)
                    array.push(lvl_ratios, ratio)
                    array.push(lvl_is_buy, is_buy)
                    array.push(lvl_scores, score)
                    array.push(lvl_bars, b)

    // Sort by strength score
    if array.size(lvl_scores) > 1
        sort_size = array.size(lvl_scores)
        for x = 0 to math.min(sort_size - 1, 50)
            for y = 0 to sort_size - 2
                if array.get(lvl_scores, y + 1) > array.get(lvl_scores, y)
                    tmp_p = array.get(lvl_prices, y)
                    tmp_b = array.get(lvl_buys, y)
                    tmp_s = array.get(lvl_sells, y)
                    tmp_r = array.get(lvl_ratios, y)
                    tmp_i = array.get(lvl_is_buy, y)
                    tmp_sc = array.get(lvl_scores, y)
                    tmp_bar = array.get(lvl_bars, y)

                    array.set(lvl_prices, y, array.get(lvl_prices, y + 1))
                    array.set(lvl_buys, y, array.get(lvl_buys, y + 1))
                    array.set(lvl_sells, y, array.get(lvl_sells, y + 1))
                    array.set(lvl_ratios, y, array.get(lvl_ratios, y + 1))
                    array.set(lvl_is_buy, y, array.get(lvl_is_buy, y + 1))
                    array.set(lvl_scores, y, array.get(lvl_scores, y + 1))
                    array.set(lvl_bars, y, array.get(lvl_bars, y + 1))

                    array.set(lvl_prices, y + 1, tmp_p)
                    array.set(lvl_buys, y + 1, tmp_b)
                    array.set(lvl_sells, y + 1, tmp_s)
                    array.set(lvl_ratios, y + 1, tmp_r)
                    array.set(lvl_is_buy, y + 1, tmp_i)
                    array.set(lvl_scores, y + 1, tmp_sc)
                    array.set(lvl_bars, y + 1, tmp_bar)

    lvl_used = array.new_bool()
    if array.size(lvl_prices) > 0
        for i = 0 to array.size(lvl_prices) - 1
            array.push(lvl_used, false)

    // ========== KEY LEVELS SECTION ==========
    table.cell(main_tbl, 0, 0, "âš¡ KEY LEVELS", text_color=col_accent, text_size=size.normal, bgcolor=color.new(color.black, 0))
    table.merge_cells(main_tbl, 0, 0, 6, 0)

    row_idx = 1
    max_key_rows = 5
    if array.size(lvl_prices) > 0
        for offset = 0 to lookback - 1
            if row_idx > max_key_rows
                break

            best_idx = -1
            best_score = 0.0

            for i = 0 to array.size(lvl_prices) - 1
                if not array.get(lvl_used, i) and array.get(lvl_bars, i) == offset
                    price = array.get(lvl_prices, i)
                    ratio = array.get(lvl_ratios, i)
                    score = array.get(lvl_scores, i)
                    [hit, _, _, _, _] = active_meta(price)
                    if ratio >= 3.0 or hit
                        if best_idx == -1 or score > best_score
                            best_idx := i
                            best_score := score

            if best_idx >= 0
                price = array.get(lvl_prices, best_idx)
                ratio = array.get(lvl_ratios, best_idx)
                is_buy = array.get(lvl_is_buy, best_idx)
                score = array.get(lvl_scores, best_idx)
                [hit, stacked_hit, retest_hit, _, _] = active_meta(price)

                if ratio >= ob_ratio or (ratio >= 3.0 and hit)
                    bg = is_buy ? color.new(col_buy, 55) : color.new(col_sell, 55)
                    side_col = is_buy ? col_buy : col_sell
                    table.cell(main_tbl, 0, row_idx, str.tostring(price, format.mintick), text_color=color.white, text_size=size.small, bgcolor=bg)
                    table.cell(main_tbl, 1, row_idx, stacked_hit ? "â§‰" : "", text_color=col_accent, text_size=size.tiny, bgcolor=bg)
                    table.cell(main_tbl, 2, row_idx, retest_hit ? "â†º" : "", text_color=col_accent, text_size=size.tiny, bgcolor=bg)
                    table.cell(main_tbl, 3, row_idx, str.tostring(score, "#.##"), text_color=side_col, text_size=size.small, bgcolor=bg)
                    table.cell(main_tbl, 4, row_idx, str.tostring(ratio, "#.#") + ":1", text_color=side_col, text_size=size.small, bgcolor=bg)
                    table.cell(main_tbl, 5, row_idx, is_buy ? "BUY" : "SELL", text_color=side_col, text_size=size.small, bgcolor=bg)
                    table.cell(main_tbl, 6, row_idx, hit ? "ðŸŽ¯" : "", text_color=col_accent, text_size=size.small, bgcolor=bg)

                    array.set(lvl_used, best_idx, true)
                    row_idx += 1

    // Fill empty key level rows
    while row_idx < 6
        table.cell(main_tbl, 0, row_idx, "-", text_color=color.gray, text_size=size.tiny, bgcolor=color.new(color.gray, 85))
        table.cell(main_tbl, 1, row_idx, "", bgcolor=color.new(color.gray, 85))
        table.cell(main_tbl, 2, row_idx, "", bgcolor=color.new(color.gray, 85))
        table.cell(main_tbl, 3, row_idx, "-", text_color=color.gray, text_size=size.tiny, bgcolor=color.new(color.gray, 85))
        table.cell(main_tbl, 4, row_idx, "-", text_color=color.gray, text_size=size.tiny, bgcolor=color.new(color.gray, 85))
        table.cell(main_tbl, 5, row_idx, "-", text_color=color.gray, text_size=size.tiny, bgcolor=color.new(color.gray, 85))
        table.cell(main_tbl, 6, row_idx, "", bgcolor=color.new(color.gray, 85))
        row_idx += 1

    // ========== ORDER FLOW SECTION ==========
    table.cell(main_tbl, 0, 6, "ORDER FLOW", text_color=col_accent, text_size=size.small, bgcolor=color.new(color.gray, 70))
    table.merge_cells(main_tbl, 0, 6, 6, 6)

    table.cell(main_tbl, 0, 7, "Price", text_color=color.white, text_size=size.tiny, bgcolor=color.new(color.gray, 70))
    table.cell(main_tbl, 1, 7, "Buy", text_color=col_buy, text_size=size.tiny, bgcolor=color.new(color.gray, 70))
    table.cell(main_tbl, 2, 7, "Sell", text_color=col_sell, text_size=size.tiny, bgcolor=color.new(color.gray, 70))
    table.cell(main_tbl, 3, 7, "Delta", text_color=col_accent, text_size=size.tiny, bgcolor=color.new(color.gray, 70))
    table.cell(main_tbl, 4, 7, "Ratio", text_color=color.white, text_size=size.tiny, bgcolor=color.new(color.gray, 70))
    table.cell(main_tbl, 5, 7, "Score", text_color=col_accent, text_size=size.tiny, bgcolor=color.new(color.gray, 70))
    table.cell(main_tbl, 6, 7, "Type", text_color=color.white, text_size=size.tiny, bgcolor=color.new(color.gray, 70))
    
    // Display order flow rows
    max_rows = 9
    if array.size(lvl_prices) > 0
        for i = 0 to math.min(array.size(lvl_prices) - 1, max_rows - 1)
            price = array.get(lvl_prices, i)
            bv = array.get(lvl_buys, i)
            sv = array.get(lvl_sells, i)
            ratio = array.get(lvl_ratios, i)
            is_buy = array.get(lvl_is_buy, i)
            score = array.get(lvl_scores, i)
            delta = bv - sv

            row = i + 8

            base_bg = is_buy ? color.new(col_buy, 82) : color.new(col_sell, 82)
            strong_bg = is_buy ? color.new(col_buy, 65) : color.new(col_sell, 65)
            mid_bg = is_buy ? color.new(col_buy, 75) : color.new(col_sell, 75)

            bg = mid_bg
            txt_sz = size.tiny

            if ratio >= ob_ratio
                bg := strong_bg
                txt_sz := size.small
            else if ratio >= 4.0
                bg := mid_bg
            else
                bg := base_bg

            table.cell(main_tbl, 0, row, str.tostring(price, format.mintick), text_color=color.white, text_size=txt_sz, bgcolor=bg)
            table.cell(main_tbl, 1, row, str.tostring(math.round(bv)), text_color=col_buy, text_size=txt_sz, bgcolor=bg)
            table.cell(main_tbl, 2, row, str.tostring(math.round(sv)), text_color=col_sell, text_size=txt_sz, bgcolor=bg)
            table.cell(main_tbl, 3, row, str.tostring(math.round(delta)), text_color=delta > 0 ? col_buy : col_sell, text_size=txt_sz, bgcolor=bg)
            table.cell(main_tbl, 4, row, str.tostring(ratio, "#.#") + ":1", text_color=is_buy ? col_buy : col_sell, text_size=txt_sz, bgcolor=bg)
            table.cell(main_tbl, 5, row, str.tostring(score, "#.##"), text_color=is_buy ? col_buy : col_sell, text_size=txt_sz, bgcolor=bg)
            table.cell(main_tbl, 6, row, is_buy ? "BUY" : "SELL", text_color=is_buy ? col_buy : col_sell, text_size=txt_sz, bgcolor=bg)

// ==================== ACTIVE COUNT LABEL ====================
var label count_lbl = na

if barstate.islast
    if not na(count_lbl)
        label.delete(count_lbl)
    
    buy_cnt = 0
    sell_cnt = 0
    if array.size(ob_active) > 0
        for i = 0 to array.size(ob_active) - 1
            if array.get(ob_active, i)
                if array.get(ob_sides, i) == "buy"
                    buy_cnt += 1
                else
                    sell_cnt += 1
    
    if buy_cnt > 0 or sell_cnt > 0
        txt = str.tostring(buy_cnt + sell_cnt) + " KEY"
        count_lbl := label.new(bar_index + 2, high, txt, color=color.new(col_accent, 20), textcolor=color.black, style=label.style_label_left, size=size.normal)
