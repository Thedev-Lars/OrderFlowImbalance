//@version=6
indicator("LarsTrades Order Flow Zones", overlay=true, max_boxes_count=500, max_labels_count=500, max_lines_count=500)

// ============================================================================
// INPUTS
// ============================================================================

// Order Flow Settings
imbalanceRatio = input.float(3.0, "Imbalance Ratio Threshold", minval=2.0, step=0.1, group="Order Flow Detection")
minLevelVolume = input.int(10, "Min Volume Per Level", minval=1, group="Order Flow Detection")
priceLevelsPerBar = input.int(10, "Price Levels Per Bar", minval=5, maxval=20, group="Order Flow Detection")
barsToShow = input.int(6, "Bars to Show in History", minval=3, maxval=10, group="Order Flow Detection")

// Key Level Settings
maxKeyLevels = input.int(8, "Max Key Ranges to Track", minval=3, maxval=15, group="Key Levels")
rangeMergeTicks = input.float(5.0, "Range Merge Distance (Ticks)", minval=2.0, step=0.5, group="Key Levels")

// Tiering thresholds
extremeRatio = input.float(8.0, "EXTREME Tier Threshold", minval=6.0, step=0.5, group="Tiering")
strongRatio = input.float(5.0, "STRONG Tier Threshold", minval=4.0, step=0.5, group="Tiering")

// Display Settings
showBoxes = input.bool(true, "Show Imbalance Boxes", group="Display")
showTradeLines = input.bool(true, "Show Trade Lines", group="Display")
showClosedTradeBoxes = input.bool(true, "Show Closed Trade Boxes", group="Display")
closedTradeBoxOpacity = input.int(75, "Closed Box Opacity", minval=10, maxval=95, group="Display")
showTables = input.bool(true, "Show Tables", group="Display")
mobileCompact = input.bool(false, "Mobile Compact Mode", group="Display")
showTradeVisuals = input.bool(true, "Show On-Chart Trade Visuals", group="Display")

// Performance Controls
resetPerformance = input.bool(false, "Reset Performance", group="Performance")

// Trade Settings
minRR = input.float(3.0, "Minimum Risk:Reward Ratio", minval=2.0, step=0.5, group="Trade Logic")
rejectionBuffer = input.float(5.0, "Stop Loss Buffer (Ticks)", minval=1.0, step=0.5, group="Trade Logic")
profitConfirmBars = input.int(2, "Bars to Confirm Profit", minval=1, maxval=5, group="Trade Logic")
// New setting: number of bars to confirm a stop loss hit (Option C - give trades room to breathe)
stopConfirmBars   = input.int(2, "Bars to Confirm Stop Loss", minval=1, maxval=5, group="Trade Logic")
zoneConfirmBars   = input.int(2, "Bars to Confirm Zone Break", minval=1, maxval=10, group="Trade Logic")
wickToleranceTicks = input.float(2.0, "Zone Wick Tolerance (Ticks)", minval=0.0, step=0.5, group="Trade Logic")
maxRR_input        = input.float(4.0,  "Maximum Risk:Reward Ratio", minval=0.0, step=0.5, group="Trade Logic")
maxRR = math.max(maxRR_input, minRR)
atrLength    = input.int(14,     "ATR Length",                minval=1,                group="Trade Logic")
atrMult      = input.float(0.5,  "ATR Multiplier",            minval=0.0, step=0.1,  group="Trade Logic")
minStopTicks = input.float(25.0, "Min Stop Size (Ticks)",     minval=1.0, step=1.0,  group="Trade Logic")
maxStopTicks = input.float(80.0, "Max Stop Size (Ticks)",     minval=5.0, step=1.0,  group="Trade Logic")
swingLookback = input.int(10, "Swing Lookback Bars", minval=1, maxval=100, group="Trade Logic")
showDebug = input.bool(false, "Dev: Show Stop/Target Debug", group = "Trade Logic")
expireBars = input.int(50, "Trade Idea Expiration (bars)", minval=1, maxval=500, group="Trade Logic")

// ----------------------------------------------------------------------------
// Trade Filter Settings
//
// These inputs allow users to filter trade setups based on the prevailing
// trend and the amount of opposing volume within a key imbalance.  The trend
// filter compares price to a simple moving average to determine whether the
// market is trending up or down.  The opposing volume filter rejects levels
// where too much volume comes from the opposite side of the imbalance.
// "Extreme" tiers can override the filters.
trendFilterEnabled = input.bool(true, "Use trend filter?", group="Trade Filter")
trendPeriod       = input.int(50, "Trend MA period", minval=10, maxval=200, group="Trade Filter")
maxOpposingPct    = input.float(0.10, "Max opposing volume %", minval=0.01, maxval=0.5, step=0.01, group="Trade Filter")

// Colors
col_buy = input.color(#00ff41, "Buy Color", group="Colors")
col_sell = input.color(#b968ff, "Sell Color", group="Colors")
col_stop = input.color(#ff0000, "Stop Loss Color", group="Colors")
col_target = input.color(#ffeb3b, "Take Profit Color", group="Colors")
buyColor = color.new(color.lime, 0)
sellColor = color.new(color.purple, 0)
riskColor = color.new(color.red, 85)
rewardColor = color.new(color.green, 85)
neutralLine = color.new(color.yellow, 10)

// ============================================================================
// ORDER FLOW ENGINE
// ============================================================================

atr_value = ta.atr(atrLength)
bucket_size = atr_value / priceLevelsPerBar
float swingLowCalc = ta.lowest(low, swingLookback)
float swingHighCalc = ta.highest(high, swingLookback)

float barBuyVol = close > open ? volume * 0.7 : volume * 0.3
float barSellVol = close > open ? volume * 0.3 : volume * 0.7
float barDelta = barBuyVol - barSellVol

// ---------------------------------------------------------------------------
// Trend calculation for trade filtering
// Compute a simple moving average of the closing price over the user-specified
// period and derive a directional string.  When the close is above the
// moving average we consider the trend to be up, otherwise down.  These
// values are used later to determine whether a key level aligns with the
// prevailing market direction.
float trendMA = ta.sma(close, trendPeriod)
string trendDir = close > trendMA ? "up" : "down"
float atr = ta.atr(atrLength)
// Quality filters for trade idea generation
int maxDistanceTicks = input.int(80, "Max Distance to Entry (ticks)", minval=1, group="Trade Logic")
float minStrength = 10

calc_bar_levels(int lookback_offset) =>
    if bar_index < lookback_offset
        [array.new_float(), array.new_float(), array.new_float()]
    else
        float h = high[lookback_offset]
        float l = low[lookback_offset]
        float c = close[lookback_offset]
        float o = open[lookback_offset]
        float v = volume[lookback_offset]
        
        if na(h) or na(l) or na(c) or na(o) or na(v)
            [array.new_float(), array.new_float(), array.new_float()]
        else
            float bar_buy = c > o ? v * 0.7 : v * 0.3
            float bar_sell = c > o ? v * 0.3 : v * 0.7
            
            var float[] prices = array.new_float()
            var float[] buys = array.new_float()
            var float[] sells = array.new_float()
            
            array.clear(prices)
            array.clear(buys)
            array.clear(sells)
            
            float bar_range = h - l
            
            if bar_range <= 0 or na(bar_range)
                [array.new_float(), array.new_float(), array.new_float()]
            else
                int levels = math.max(1, math.floor(bar_range / bucket_size))
                levels := math.min(levels, priceLevelsPerBar)
                
                float level_height = bar_range / levels
                
                for i = 0 to levels - 1
                    float lvl_bottom = l + (i * level_height)
                    float lvl_top = l + ((i + 1) * level_height)
                    float lvl_mid = (lvl_bottom + lvl_top) / 2
                    
                    float position_pct = (lvl_mid - l) / bar_range
                    float buy_weight = c > o ? position_pct : (1 - position_pct)
                    float sell_weight = 1 - buy_weight
                    
                    float level_buy = (bar_buy / levels) * (0.5 + buy_weight * 0.5)
                    float level_sell = (bar_sell / levels) * (0.5 + sell_weight * 0.5)
                    
                    array.push(prices, lvl_mid)
                    array.push(buys, level_buy)
                    array.push(sells, level_sell)
                
                [prices, buys, sells]

// ============================================================================
// KEY LEVEL MODEL
// ============================================================================

// Status states with ENTRY
var string STATE_ACTIVE = "ACTIVE"
var string STATE_ENTRY = "ENTRY"        // NEW: Trade setup ready
var string STATE_TESTING = "TESTING"    // Trade is live
var string STATE_PROFIT = "PROFIT"
var string STATE_HELD = "HELD"
var string STATE_REJECTED = "REJECTED"
var string STATE_CLOSED = "CLOSED"

// New state representing a losing trade.  When a trade is entered and the
// stop loss is confirmed, the level transitions to LOSS instead of REJECTED.
var string STATE_LOSS = "LOSS"

// Tier labels
var string TIER_EXTREME = "EXT"
var string TIER_STRONG = "STR"
var string TIER_MODERATE = "MOD"

// Persistent arrays
var float[] kl_range_top = array.new_float()
var float[] kl_range_bottom = array.new_float()
var float[] kl_poc = array.new_float()
var float[] kl_swing_price = array.new_float()
var string[] kl_side = array.new_string()
var float[] kl_strength = array.new_float()
var float[] kl_peak_ratio = array.new_float()
var float[] kl_avg_ratio = array.new_float()
var float[] kl_poc_volume = array.new_float()
var float[] kl_net_delta = array.new_float()
var float[] kl_total_volume = array.new_float()
var string[] kl_tier = array.new_string()
var int[] kl_origin_bar = array.new_int()
var string[] kl_state = array.new_string()
var int[] kl_test_count = array.new_int()
var box[] kl_box = array.new_box()
var int[] kl_last_test_bar = array.new_int()

// Setup Engine states
var string SETUP_READY = "SETUP_READY"
var string WAITING_FOR_RETEST = "WAITING_FOR_RETEST"
var string OPEN_TRADE = "OPEN_TRADE"
var string CLOSED_TRADE = "CLOSED_TRADE"
var string INVALIDATED = "INVALIDATED"

// Setup Engine tracking arrays
var float[] setup_entryPrice = array.new_float()
var float[] setup_stopPrice = array.new_float()
var float[] setup_scalpTarget = array.new_float()
var float[] setup_runnerTarget = array.new_float()
var string[] setup_direction = array.new_string()
var float[] setup_zoneTop = array.new_float()
var float[] setup_zoneBottom = array.new_float()
var float[] setup_pocPrice = array.new_float()
var float[] setup_strengthScore = array.new_float()
var string[] setup_state = array.new_string()
var int[] setup_pocConfirm = array.new_int()
var int[] setup_stopConfirm = array.new_int()
var int[] setup_scalpConfirm = array.new_int()
var int[] setup_runnerConfirm = array.new_int()

// Trade Engine v2 scaffolding
var int TE_STATE_ACTIVE = 0
var int TE_STATE_POSSIBLE = 1
var int TE_STATE_OPEN = 2
var int TE_STATE_CLOSED_WIN = 3
var int TE_STATE_CLOSED_LOSS = 4
var int TE_STATE_REJECTED = 5

var int[] trade_state = array.new_int()
var bool[] trade_opened = array.new_bool()
var float[] trade_entry = array.new_float()
var float[] trade_stop = array.new_float()
var float[] trade_target = array.new_float()
var float[] trade_ticks = array.new_float()

// Trade visualization arrays
var float[] kl_entry_price = array.new_float()
var float[] kl_stop_price = array.new_float()
var float[] kl_target_price = array.new_float()
var float[] kl_rr_ratio = array.new_float()
var line[] kl_entry_line = array.new_line()
var line[] kl_stop_line = array.new_line()
var line[] kl_target_line = array.new_line()
var label[] kl_trade_label = array.new_label()
var int[] kl_reject_count = array.new_int()
var int[] kl_break_bars = array.new_int()
var bool[] kl_poc_tagged = array.new_bool()
var string[] kl_outcome = array.new_string()
var float[] kl_realized_ticks = array.new_float()
var bool[] kl_closed_logged = array.new_bool()
var int[] trade_entry_bar = array.new_int()
var int[] trade_created_bar = array.new_int()

// Dev debug overlay objects
var line debugEntryLine = na
var line debugStopLine = na
var line debugTargetLine = na
var label debugLabel = na

// Persistent storage for closed trades (per session)
var string[] closed_side = array.new_string()
var float[] closed_entry = array.new_float()
var float[] closed_stop = array.new_float()
var float[] closed_target = array.new_float()
var float[] closed_rr = array.new_float()
var float[] closed_ticks = array.new_float()
var float[] closed_trade_rr = array.new_float()
var string[] closed_result = array.new_string()
var box[] closed_trade_boxes = array.new_box()
var int[] trade_closed_bar = array.new_int()
var int[] trade_visual_ids = array.new_int()
var line[] trade_visual_entry_lines = array.new_line()
var box[] trade_visual_risk_boxes = array.new_box()
var box[] trade_visual_reward_boxes = array.new_box()
var line ot_entryLine = na
var line ot_stopLine = na
var line ot_targetLine = na
var box ot_riskBox = na
var box ot_rewardBox = na

f_safe_get(arr, int idx) =>
    idx >= 0 and idx < array.size(arr) ? array.get(arr, idx) : na

// Trade lifecycle state machine
type Trade
    int id
    int kl_id
    int direction
    float entry
    float stop
    float take
    string status   // "set", "open", "closed"
    float pnlTicks

var Trade[] trades_set = array.new<Trade>()
var Trade[] trades_open = array.new<Trade>()
var Trade[] trades_closed = array.new<Trade>()
var int trade_seq = 0

type TimelineEvent
    int bar
    string event
    string dir
    float entry
    float stop
    float take
    float pnlTicks
    float rr

var TimelineEvent[] timeline = array.new<TimelineEvent>()

var bool perfResetLatched = false

// Session management
var int last_session_day = 0
int current_day = dayofmonth(time)
clear_performance_history() =>
    array.clear(closed_side)
    array.clear(closed_entry)
    array.clear(closed_stop)
    array.clear(closed_target)
    array.clear(closed_rr)
    array.clear(closed_ticks)
    array.clear(closed_trade_rr)
    array.clear(closed_result)
    if array.size(closed_trade_boxes) > 0
        for i = 0 to array.size(closed_trade_boxes) - 1
            box.delete(array.get(closed_trade_boxes, i))
    array.clear(closed_trade_boxes)

find_trade_visual_index(int id) =>
    int found = -1
    if array.size(trade_visual_ids) > 0
        for i = 0 to array.size(trade_visual_ids) - 1
            if array.get(trade_visual_ids, i) == id
                found := i
                break
    found

clear_trade_visuals() =>
    int entry_count = array.size(trade_visual_entry_lines)
    if entry_count > 0
        for i = entry_count - 1 to 0
            line ln = f_safe_get(trade_visual_entry_lines, i)
            if not na(ln)
                line.delete(ln)
    int risk_count = array.size(trade_visual_risk_boxes)
    if risk_count > 0
        for i = risk_count - 1 to 0
            box bx = f_safe_get(trade_visual_risk_boxes, i)
            if not na(bx)
                box.delete(bx)
    int reward_count = array.size(trade_visual_reward_boxes)
    if reward_count > 0
        for i = reward_count - 1 to 0
            box bx = f_safe_get(trade_visual_reward_boxes, i)
            if not na(bx)
                box.delete(bx)
    array.clear(trade_visual_ids)
    array.clear(trade_visual_entry_lines)
    array.clear(trade_visual_risk_boxes)
    array.clear(trade_visual_reward_boxes)

if current_day != last_session_day
    if array.size(kl_box) > 0
        for i = 0 to array.size(kl_box) - 1
            box.delete(array.get(kl_box, i))
            if not na(array.get(kl_entry_line, i))
                line.delete(array.get(kl_entry_line, i))
            if not na(array.get(kl_stop_line, i))
                line.delete(array.get(kl_stop_line, i))
            if not na(array.get(kl_target_line, i))
                line.delete(array.get(kl_target_line, i))
            if not na(array.get(kl_trade_label, i))
                label.delete(array.get(kl_trade_label, i))
    array.clear(kl_range_top)
    array.clear(kl_range_bottom)
    array.clear(kl_poc)
    array.clear(kl_swing_price)
    array.clear(kl_side)
    array.clear(kl_strength)
    array.clear(kl_peak_ratio)
    array.clear(kl_avg_ratio)
    array.clear(kl_poc_volume)
    array.clear(kl_net_delta)
    array.clear(kl_total_volume)
    array.clear(kl_tier)
    array.clear(kl_origin_bar)
    array.clear(kl_state)
    array.clear(kl_test_count)
    array.clear(kl_box)
    array.clear(kl_last_test_bar)
    array.clear(kl_entry_price)
    array.clear(kl_stop_price)
    array.clear(kl_target_price)
    array.clear(kl_rr_ratio)
    array.clear(kl_entry_line)
    array.clear(kl_stop_line)
    array.clear(kl_target_line)
    array.clear(kl_trade_label)
    array.clear(kl_reject_count)
    array.clear(kl_outcome)
    array.clear(kl_realized_ticks)
    array.clear(kl_closed_logged)
    array.clear(kl_break_bars)
    array.clear(kl_poc_tagged)
    array.clear(trade_entry_bar)
    array.clear(trade_state)
    array.clear(trade_opened)
    array.clear(trade_entry)
    array.clear(trade_stop)
    array.clear(trade_target)
    array.clear(trade_ticks)
    array.clear(trade_created_bar)
    array.clear(trade_closed_bar)
    array.clear(trades_set)
    array.clear(trades_open)
    array.clear(trades_closed)
    array.clear(setup_entryPrice)
    array.clear(setup_stopPrice)
    array.clear(setup_scalpTarget)
    array.clear(setup_runnerTarget)
    array.clear(setup_direction)
    array.clear(setup_zoneTop)
    array.clear(setup_zoneBottom)
    array.clear(setup_pocPrice)
    array.clear(setup_strengthScore)
    array.clear(setup_state)
    array.clear(setup_pocConfirm)
    array.clear(setup_stopConfirm)
    array.clear(setup_scalpConfirm)
    array.clear(setup_runnerConfirm)
    trade_seq := 0
    clear_trade_visuals()
    clear_performance_history()
    last_session_day := current_day

if resetPerformance and not perfResetLatched
    clear_performance_history()
    perfResetLatched := true
else if not resetPerformance
    perfResetLatched := false

record_closed_trade(int idx) =>
    if idx >= 0 and idx < array.size(kl_closed_logged) and not array.get(kl_closed_logged, idx)
        float entry = array.get(kl_entry_price, idx)
        float stop = array.get(kl_stop_price, idx)
        float target = array.get(kl_target_price, idx)
        string outcome_val = array.get(kl_outcome, idx)
        string side_val = array.get(kl_side, idx)
        float exit_price = outcome_val == "Profit" ? target : stop

        float risk_price = math.abs(entry - stop)
        float pnl_price = na
        if side_val == "buy"
            pnl_price := exit_price - entry
        else if side_val == "sell"
            pnl_price := entry - exit_price

        float realized_rr = na
        if risk_price > 0 and not na(pnl_price)
            realized_rr := pnl_price / risk_price

        array.push(closed_side, array.get(kl_side, idx))
        array.push(closed_entry, array.get(kl_entry_price, idx))
        array.push(closed_stop, array.get(kl_stop_price, idx))
        array.push(closed_target, array.get(kl_target_price, idx))
        array.push(closed_rr, array.get(kl_rr_ratio, idx))
        array.push(closed_ticks, array.get(kl_realized_ticks, idx))
        array.push(closed_trade_rr, realized_rr)
        array.push(closed_result, array.get(kl_outcome, idx))
        array.set(kl_closed_logged, idx, true)

finalize_close(int idx, string outcome, float ticks_val) =>
    bool eligible_close = not (idx < 0 or idx >= array.size(trade_state) or array.get(trade_state, idx) != TE_STATE_OPEN)
    if eligible_close
        // Skip if already logged or index is out of sync
        bool base_loggable = idx >= 0 and idx < array.size(kl_state) and idx < array.size(kl_closed_logged) and not array.get(kl_closed_logged, idx)
        int ts = idx >= 0 and idx < array.size(trade_state) ? array.get(trade_state, idx) : na
        bool trade_live = ts == TE_STATE_OPEN
        bool trade_entered = idx >= 0 and idx < array.size(trade_opened) ? array.get(trade_opened, idx) : false
        bool has_prices = idx < array.size(kl_entry_price) and idx < array.size(kl_stop_price) and not na(array.get(kl_entry_price, idx)) and not na(array.get(kl_stop_price, idx))
        bool already_closed = idx < array.size(trade_closed_bar) and not na(array.get(trade_closed_bar, idx))
        bool loggable = base_loggable and trade_live and trade_entered and has_prices and not already_closed
        if loggable
            array.set(kl_realized_ticks, idx, ticks_val)
            array.set(kl_outcome, idx, outcome)
            array.set(kl_state, idx, STATE_CLOSED)
            if idx < array.size(trade_state)
                array.set(trade_state, idx, outcome == "Profit" ? TE_STATE_CLOSED_WIN : TE_STATE_CLOSED_LOSS)
            array.set(kl_last_test_bar, idx, bar_index)
            if idx < array.size(trade_closed_bar)
                array.set(trade_closed_bar, idx, bar_index)
            record_closed_trade(idx)

            // Draw a persistent closed-trade box from entry to exit
            float entry_price = array.get(kl_entry_price, idx)
            float exit_price = outcome == "Profit" ? array.get(kl_target_price, idx) : array.get(kl_stop_price, idx)
            int entry_bar_idx = idx < array.size(trade_entry_bar) and not na(array.get(trade_entry_bar, idx)) ? array.get(trade_entry_bar, idx) : bar_index
            float top = math.max(entry_price, exit_price)
            float bottom = math.min(entry_price, exit_price)
            color box_col = color.new(color.white, closedTradeBoxOpacity)
            box closed_box = box.new(left=entry_bar_idx, top=top, right=bar_index + 1, bottom=bottom, border_color=box_col, bgcolor=box_col, border_width=1)
            array.push(closed_trade_boxes, closed_box)

            int max_closed_boxes = 60
            if array.size(closed_trade_boxes) > max_closed_boxes
                box.delete(array.shift(closed_trade_boxes))
    eligible_close

find_trade_index(Trade[] arr, int kl_idx) =>
    int found = -1
    int arr_count = array.size(arr)
    if arr_count > 0
        for i = 0 to arr_count - 1
            Trade t = array.get(arr, i)
            if t.kl_id == kl_idx
                found := i
                break
    found

has_open_trade() =>
    bool found_open = false
    int n = array.size(trade_state)
    if n > 0
        for j = 0 to n - 1
            if array.get(trade_state, j) == TE_STATE_OPEN
                found_open := true
                break
    found_open

log_timeline(string event, string dir, float entry, float stop, float take, float pnlTicks, float rr) =>
    TimelineEvent ev = TimelineEvent.new(bar_index, event, dir, entry, stop, take, pnlTicks, rr)
    array.push(timeline, ev)
    ev

swap_trade_indices(int a, int b) =>
    Trade[] arr_ref = trades_set
    if array.size(arr_ref) > 0
        for i = 0 to array.size(arr_ref) - 1
            Trade t = array.get(arr_ref, i)
            if t.kl_id == a
                t.kl_id := b
                array.set(arr_ref, i, t)
            else if t.kl_id == b
                t.kl_id := a
                array.set(arr_ref, i, t)

    arr_ref := trades_open
    if array.size(arr_ref) > 0
        for i = 0 to array.size(arr_ref) - 1
            Trade t = array.get(arr_ref, i)
            if t.kl_id == a
                t.kl_id := b
                array.set(arr_ref, i, t)
            else if t.kl_id == b
                t.kl_id := a
                array.set(arr_ref, i, t)

    arr_ref := trades_closed
    if array.size(arr_ref) > 0
        for i = 0 to array.size(arr_ref) - 1
            Trade t = array.get(arr_ref, i)
            if t.kl_id == a
                t.kl_id := b
                array.set(arr_ref, i, t)
            else if t.kl_id == b
                t.kl_id := a
                array.set(arr_ref, i, t)

remove_trades_for_index(int idx) =>
    int remove_i = find_trade_index(trades_set, idx)
    if remove_i != -1
        array.remove(trades_set, remove_i)

    remove_i := find_trade_index(trades_open, idx)
    if remove_i != -1
        array.remove(trades_open, remove_i)

ensure_trade_visual(Trade t, string state_label) =>
    bool has_prices = not na(t.entry) and not na(t.stop) and not na(t.take)
    if has_prices
        int vis_idx = find_trade_visual_index(t.id)
        if vis_idx == -1
            line ln_new = line.new(bar_index, t.entry, bar_index + 1, t.entry, extend=extend.right, color=neutralLine, width=1, style=line.style_dotted)
            float risk_top = math.max(t.entry, t.stop)
            float risk_bottom = math.min(t.entry, t.stop)
            float reward_top = math.max(t.entry, t.take)
            float reward_bottom = math.min(t.entry, t.take)
            box risk_box_new = box.new(bar_index, risk_top, bar_index + 1, risk_bottom, bgcolor=color.new(riskColor, 90), border_color=color.new(riskColor, 90), extend=extend.right)
            box reward_box_new = box.new(bar_index, reward_top, bar_index + 1, reward_bottom, bgcolor=color.new(rewardColor, 90), border_color=color.new(rewardColor, 90), extend=extend.right)
            array.push(trade_visual_ids, t.id)
            array.push(trade_visual_entry_lines, ln_new)
            array.push(trade_visual_risk_boxes, risk_box_new)
            array.push(trade_visual_reward_boxes, reward_box_new)
            vis_idx := array.size(trade_visual_ids) - 1

        line ln = array.get(trade_visual_entry_lines, vis_idx)
        box risk_box = array.get(trade_visual_risk_boxes, vis_idx)
        box reward_box = array.get(trade_visual_reward_boxes, vis_idx)

        if na(ln)
            ln := line.new(bar_index, t.entry, bar_index + 1, t.entry, extend=extend.right, color=neutralLine, width=1, style=line.style_dotted)
            array.set(trade_visual_entry_lines, vis_idx, ln)
        if na(risk_box)
            float risk_top = math.max(t.entry, t.stop)
            float risk_bottom = math.min(t.entry, t.stop)
            risk_box := box.new(bar_index, risk_top, bar_index + 1, risk_bottom, bgcolor=color.new(riskColor, 90), border_color=color.new(riskColor, 90), extend=extend.right)
            array.set(trade_visual_risk_boxes, vis_idx, risk_box)
        if na(reward_box)
            float reward_top = math.max(t.entry, t.take)
            float reward_bottom = math.min(t.entry, t.take)
            reward_box := box.new(bar_index, reward_top, bar_index + 1, reward_bottom, bgcolor=color.new(rewardColor, 90), border_color=color.new(rewardColor, 90), extend=extend.right)
            array.set(trade_visual_reward_boxes, vis_idx, reward_box)

        line.set_extend(ln, extend.right)
        line.set_y1(ln, t.entry)
        line.set_y2(ln, t.entry)

        float risk_top_now = math.max(t.entry, t.stop)
        float risk_bottom_now = math.min(t.entry, t.stop)
        float reward_top_now = math.max(t.entry, t.take)
        float reward_bottom_now = math.min(t.entry, t.take)

        box.set_extend(risk_box, extend.right)
        box.set_top(risk_box, risk_top_now)
        box.set_bottom(risk_box, risk_bottom_now)
        box.set_extend(reward_box, extend.right)
        box.set_top(reward_box, reward_top_now)
        box.set_bottom(reward_box, reward_bottom_now)

        color line_col = neutralLine
        var line_style_val = line.style_dotted
        int line_w = 1
        color risk_bg = color.new(riskColor, 90)
        color reward_bg = color.new(rewardColor, 90)
        color risk_border = color.new(riskColor, 90)
        color reward_border = color.new(rewardColor, 90)

        if state_label == "open"
            line_col := t.direction == 1 ? buyColor : sellColor
            line_style_val := line.style_solid
            line_w := 2
            risk_bg := color.new(riskColor, 80)
            reward_bg := color.new(rewardColor, 80)
            risk_border := color.new(riskColor, 75)
            reward_border := color.new(rewardColor, 75)
        else if state_label == "closed"
            bool is_win = t.pnlTicks > 0
            line_col := color.new(t.direction == 1 ? buyColor : sellColor, 70)
            line_style_val := line.style_solid
            line_w := 1
            risk_bg := color.new(riskColor, 95)
            reward_bg := color.new(rewardColor, 95)
            risk_border := is_win ? color.new(riskColor, 95) : color.new(color.red, 20)
            reward_border := is_win ? color.new(color.green, 20) : color.new(rewardColor, 95)

        line.set_color(ln, line_col)
        line.set_style(ln, line_style_val)
        line.set_width(ln, line_w)

        box.set_bgcolor(risk_box, risk_bg)
        box.set_border_color(risk_box, risk_border)
        box.set_bgcolor(reward_box, reward_bg)
        box.set_border_color(reward_box, reward_border)

register_set_trade(int kl_idx, int seq) =>
    int updated_seq = seq
    if kl_idx >= 0 and kl_idx < array.size(kl_entry_price)
        float entry = array.get(kl_entry_price, kl_idx)
        float stop = array.get(kl_stop_price, kl_idx)
        float take = array.get(kl_target_price, kl_idx)
        string side = array.get(kl_side, kl_idx)
        bool valid_side = side == "buy" or side == "sell"
        bool has_prices = not na(entry) and not na(stop) and not na(take)
        bool price_between = side == "buy" ? (close >= stop and close <= take) : (close <= stop and close >= take)

        if valid_side and has_prices and price_between
            int dir = side == "buy" ? 1 : -1
            int existing_open = find_trade_index(trades_open, kl_idx)
            if existing_open == -1
                int existing_set = find_trade_index(trades_set, kl_idx)
                Trade t = na
                if existing_set >= 0 and existing_set < array.size(trades_set)
                    t := array.get(trades_set, existing_set)
                else
                    t := Trade.new(0, kl_idx, dir, entry, stop, take, "set", na)
                if existing_set == -1
                    updated_seq += 1
                    t.id := updated_seq
                t.kl_id := kl_idx
                t.direction := dir
                t.entry := entry
                t.stop := stop
                t.take := take
                t.status := "set"
                t.pnlTicks := na
                if existing_set == -1
                    array.push(trades_set, t)
                    log_timeline("Trade SET", side == "buy" ? "Buy" : "Sell", entry, stop, take, na, na)
                else
                    array.set(trades_set, existing_set, t)
                if kl_idx < array.size(trade_state)
                    array.set(trade_state, kl_idx, TE_STATE_POSSIBLE)
                if kl_idx < array.size(trade_created_bar)
                    array.set(trade_created_bar, kl_idx, bar_index)
                else
                    array.push(trade_created_bar, bar_index)
                if kl_idx < array.size(trade_opened)
                    array.set(trade_opened, kl_idx, false)
                if kl_idx < array.size(trade_entry)
                    array.set(trade_entry, kl_idx, entry)
                if kl_idx < array.size(trade_stop)
                    array.set(trade_stop, kl_idx, stop)
                if kl_idx < array.size(trade_target)
                    array.set(trade_target, kl_idx, take)
                if kl_idx < array.size(trade_ticks)
                    array.set(trade_ticks, kl_idx, na)
                if kl_idx < array.size(trade_entry_bar)
                    array.set(trade_entry_bar, kl_idx, na)
                if kl_idx < array.size(trade_closed_bar)
                    array.set(trade_closed_bar, kl_idx, na)
    updated_seq

open_trade_for_level(int kl_idx) =>
    bool can_open = not has_open_trade()
    if can_open
        int idx_set = find_trade_index(trades_set, kl_idx)
        if idx_set != -1
            Trade t = array.get(trades_set, idx_set)
            array.remove(trades_set, idx_set)
            t.status := "open"
            array.push(trades_open, t)
            log_timeline("Trade OPEN", t.direction == 1 ? "Buy" : "Sell", t.entry, t.stop, t.take, na, na)
            if kl_idx < array.size(trade_state)
                array.set(trade_state, kl_idx, TE_STATE_OPEN)
            if kl_idx < array.size(trade_opened)
                array.set(trade_opened, kl_idx, true)
            if kl_idx < array.size(trade_entry_bar)
                array.set(trade_entry_bar, kl_idx, bar_index)
            if kl_idx < array.size(kl_state)
                array.set(kl_state, kl_idx, STATE_TESTING)
                array.set(kl_last_test_bar, kl_idx, bar_index)
    can_open

reject_trade_for_level(int kl_idx) =>
    int idx_set = find_trade_index(trades_set, kl_idx)
    if idx_set != -1
        array.remove(trades_set, idx_set)
    if kl_idx < array.size(trade_state)
        array.set(trade_state, kl_idx, TE_STATE_REJECTED)
    if kl_idx < array.size(kl_state)
        array.set(kl_state, kl_idx, STATE_REJECTED)
        array.set(kl_outcome, kl_idx, "Rejected")
        array.set(kl_realized_ticks, kl_idx, na)

close_open_trade(int kl_idx, float exit_price, string outcome) =>
    int idx_open = find_trade_index(trades_open, kl_idx)
    int ts_open = kl_idx >= 0 and kl_idx < array.size(trade_state) ? array.get(trade_state, kl_idx) : na
    if idx_open != -1 and ts_open == TE_STATE_OPEN
        Trade t = array.get(trades_open, idx_open)
        array.remove(trades_open, idx_open)
        t.status := "closed"
        t.pnlTicks := (exit_price - t.entry) / syminfo.mintick * t.direction
        array.push(trades_closed, t)
        float risk_ticks = (t.take - t.entry) / syminfo.mintick
        float rr_val = risk_ticks != 0 ? math.abs(t.pnlTicks) / math.abs(risk_ticks) : na
        log_timeline("Trade CLOSED", t.direction == 1 ? "Buy" : "Sell", t.entry, t.stop, t.take, t.pnlTicks, rr_val)
        if kl_idx < array.size(trade_ticks)
            array.set(trade_ticks, kl_idx, t.pnlTicks)
        finalize_close(kl_idx, outcome, t.pnlTicks)

process_open_trade_bar(int kl_idx, string side) =>
    int open_idx = find_trade_index(trades_open, kl_idx)
    if open_idx != -1
        Trade t_open = array.get(trades_open, open_idx)
        float stop = t_open.stop
        float target = t_open.take

        bool sl_hit = side == "buy" ? (not na(stop) and low <= stop) : (not na(stop) and high >= stop)
        bool tp_hit = side == "buy" ? (not na(target) and high >= target) : (not na(target) and low <= target)

        if sl_hit
            log_timeline("SL hit", side == "buy" ? "Buy" : "Sell", t_open.entry, t_open.stop, t_open.take, na, na)
            close_open_trade(kl_idx, stop, "Loss")
        else if tp_hit
            log_timeline("TP hit", side == "buy" ? "Buy" : "Sell", t_open.entry, t_open.stop, t_open.take, na, na)
            close_open_trade(kl_idx, target, "Profit")

get_tier(float peak_ratio) =>
    if peak_ratio >= extremeRatio
        TIER_EXTREME
    else if peak_ratio >= strongRatio
        TIER_STRONG
    else
        TIER_MODERATE

get_tier_rank(string tier) =>
    tier == TIER_EXTREME ? 3 : tier == TIER_STRONG ? 2 : 1

// Function to find the nearest opposing imbalance POC for take profit
find_next_target(int current_idx, string current_side) =>
    float target = na
    float best_dist = na
    if current_idx >= 0 and current_idx < array.size(kl_poc)
        float current_poc = array.get(kl_poc, current_idx)

        if array.size(kl_poc) > 0
            for i = 0 to array.size(kl_poc) - 1
                if i != current_idx
                    string side = array.get(kl_side, i)
                    float poc = array.get(kl_poc, i)
                    string state = array.get(kl_state, i)

                    // Only consider active/entry/testing levels (not rejected) on the opposing side
                    bool valid_buy_target = current_side == "buy" and side == "sell" and poc > current_poc
                    bool valid_sell_target = current_side == "sell" and side == "buy" and poc < current_poc
                    if state != STATE_REJECTED and (valid_buy_target or valid_sell_target)
                        float dist = math.abs(poc - current_poc)
                        if na(best_dist) or dist < best_dist
                            best_dist := dist
                            target := poc

    target

// Create a trade for a given key level index using the unified swing + ATR stop
// model and RR-banded target selection. Returns the updated trade sequence value.
create_trade_for_level(int idx, int seq) =>
    int seq_out = seq
    if idx >= 0 and idx < array.size(kl_side) and idx < array.size(kl_poc)
        string side = array.get(kl_side, idx)
        float poc = array.get(kl_poc, idx)

        if na(side)
            seq_out
        else
            float storedSwing = array.get(kl_swing_price, idx)
            float swingPrice = na
            if not na(storedSwing)
                swingPrice := storedSwing
            else
                swingPrice := side == "buy" ? swingLowCalc : swingHighCalc

            if na(storedSwing) and not na(swingPrice)
                array.set(kl_swing_price, idx, swingPrice)

            if na(swingPrice)
                seq_out
            else
                float swingDistTicks = math.abs(poc - swingPrice) / syminfo.mintick
                float atrTicks = atr / syminfo.mintick
                float rawStopTicks = swingDistTicks + (atrTicks * atrMult)
                float clampedStopTicks = math.max(minStopTicks, math.min(rawStopTicks, maxStopTicks))
                float stop = side == "buy" ? poc - clampedStopTicks * syminfo.mintick : poc + clampedStopTicks * syminfo.mintick
                float risk = math.abs(poc - stop)

                if risk <= 0
                    seq_out
                else
                    float level_target = find_next_target(idx, side)

                    float target_to_use = na
                    float rr_to_use = na

                    if not na(level_target)
                        float reward_level = math.abs(level_target - poc)
                        float rr_level = risk > 0 ? reward_level / risk : na
                        if not na(rr_level) and rr_level >= minRR and rr_level <= maxRR
                            target_to_use := level_target
                            rr_to_use := rr_level

                    if na(target_to_use) or na(rr_to_use)
                        float dir = side == "buy" ? 1.0 : -1.0
                        target_to_use := poc + dir * (risk * minRR)
                        rr_to_use := minRR

                    if rr_to_use > maxRR
                        float dir = side == "buy" ? 1.0 : -1.0
                        target_to_use := poc + dir * (risk * maxRR)
                        rr_to_use := maxRR

                    array.set(kl_entry_price, idx, poc)
                    array.set(kl_stop_price, idx, stop)
                    array.set(kl_target_price, idx, target_to_use)
                    array.set(kl_rr_ratio, idx, rr_to_use)
                    array.set(kl_state, idx, STATE_ENTRY)
                    array.set(kl_last_test_bar, idx, bar_index)

                    array.set(trade_state, idx, TE_STATE_POSSIBLE)
                    if array.size(trade_created_bar) <= idx
                        array.push(trade_created_bar, bar_index)
                    else
                        array.set(trade_created_bar, idx, bar_index)
                    array.set(trade_opened, idx, false)
                    array.set(trade_entry, idx, poc)
                    array.set(trade_stop, idx, stop)
                    array.set(trade_target, idx, target_to_use)
                    array.set(trade_ticks, idx, na)

                    seq_out := register_set_trade(idx, seq_out)

                    seq_out
    else
        seq_out

// ============================================================================
// IMBALANCE DETECTION
// ============================================================================

if barstate.isconfirmed
    [prices, buys, sells] = calc_bar_levels(0)

    var float[] raw_prices = array.new_float()
    var float[] raw_buy_vols = array.new_float()
    var float[] raw_sell_vols = array.new_float()
    var float[] raw_ratios = array.new_float()
    var string[] raw_sides = array.new_string()
    
    array.clear(raw_prices)
    array.clear(raw_buy_vols)
    array.clear(raw_sell_vols)
    array.clear(raw_ratios)
    array.clear(raw_sides)

    // Compute a reference average volume per price level using a 100-bar lookback.
    // This lets us scale strength by how much volume a level carries relative to
    // recent activity so higher-volume POCs pull a larger score spread.
    float avg_bar_vol = ta.sma(volume, 100)
    float avg_level_vol = avg_bar_vol / priceLevelsPerBar
    float vol_norm = na(avg_level_vol) or avg_level_vol <= 0 ? 1 : avg_level_vol
    
    if array.size(prices) > 0
        for i = 0 to array.size(prices) - 1
            float price = array.get(prices, i)
            float buy_vol = array.get(buys, i)
            float sell_vol = array.get(sells, i)
            float total_vol = buy_vol + sell_vol

            // Use the actual buy/sell difference for delta so the KIL delta column
            // reflects the dominant side at the level's POC instead of a synthetic
            // imbalance fraction. This gives the delta column meaningful spread
            // when POC pressure shifts.
            float delta = buy_vol - sell_vol

            float ratio = buy_vol >= sell_vol ? buy_vol / math.max(sell_vol, 1) : sell_vol / math.max(buy_vol, 1)

            if ratio >= imbalanceRatio and total_vol >= minLevelVolume
                array.push(raw_prices, price)
                array.push(raw_buy_vols, buy_vol)
                array.push(raw_sell_vols, sell_vol)
                array.push(raw_ratios, ratio)
                array.push(raw_sides, buy_vol > sell_vol ? "buy" : "sell")
    
    if array.size(raw_prices) > 0
        float merge_distance = rangeMergeTicks * syminfo.mintick
        
        for i = 0 to array.size(raw_prices) - 1
            float price = array.get(raw_prices, i)
            float buy_vol = array.get(raw_buy_vols, i)
            float sell_vol = array.get(raw_sell_vols, i)
            float ratio = array.get(raw_ratios, i)
            string side = array.get(raw_sides, i)
            float delta = buy_vol - sell_vol

            bool merged = false
            float swingLowRef = swingLowCalc
            float swingHighRef = swingHighCalc
            if array.size(kl_range_top) > 0
                for j = 0 to array.size(kl_range_top) - 1
                    if array.get(kl_side, j) == side
                        float range_top = array.get(kl_range_top, j)
                        float range_bottom = array.get(kl_range_bottom, j)
                        
                        if (price >= range_bottom - merge_distance) and (price <= range_top + merge_distance)
                            float new_top = math.max(range_top, price + bucket_size / 2)
                            float new_bottom = math.min(range_bottom, price - bucket_size / 2)
                            
                            array.set(kl_range_top, j, new_top)
                            array.set(kl_range_bottom, j, new_bottom)
                            
                            float current_peak = array.get(kl_peak_ratio, j)
                            if ratio > current_peak
                                array.set(kl_peak_ratio, j, ratio)
                                array.set(kl_poc, j, price)
                                array.set(kl_poc_volume, j, buy_vol + sell_vol)
                                array.set(kl_tier, j, get_tier(ratio))
                            
                            float current_avg = array.get(kl_avg_ratio, j)
                            float new_avg = (current_avg + ratio) / 2
                            array.set(kl_avg_ratio, j, new_avg)

                            float existing_delta = array.get(kl_net_delta, j)
                            float existing_vol = array.get(kl_total_volume, j)
                            float updated_delta = existing_delta + delta
                            float updated_vol = existing_vol + (buy_vol + sell_vol)
                            array.set(kl_net_delta, j, updated_delta)
                            array.set(kl_total_volume, j, updated_vol)

                            float peak_ratio = array.get(kl_peak_ratio, j)
                            float smart_delta = updated_vol > 0 ? (math.abs(updated_delta) / updated_vol) * 100 : 0
                            float vol_factor = updated_vol > 0 ? math.sqrt(updated_vol / vol_norm) : 1
                            float imbalance_boost = math.pow(peak_ratio, 0.6)
                            float new_strength = smart_delta * imbalance_boost * vol_factor
                            array.set(kl_strength, j, new_strength)

                            // Seed a reference swing for this level if it has not been captured yet
                            if na(array.get(kl_swing_price, j))
                                float swing_ref_existing = side == "buy" ? swingLowRef : swingHighRef
                                array.set(kl_swing_price, j, swing_ref_existing)

                            array.set(kl_origin_bar, j, bar_index)
                            merged := true
                            break
            
            if not merged
                float range_top = price + bucket_size
                float range_bottom = price - bucket_size
                float total_vol = buy_vol + sell_vol
                float smart_delta = total_vol > 0 ? (math.abs(delta) / total_vol) * 100 : 0
                float vol_factor = total_vol > 0 ? math.sqrt(total_vol / vol_norm) : 1
                float strength = smart_delta * math.pow(ratio, 0.6) * vol_factor
                string tier = get_tier(ratio)
                float swing_ref = side == "buy" ? swingLowRef : swingHighRef

                array.push(kl_range_top, range_top)
                array.push(kl_range_bottom, range_bottom)
                array.push(kl_poc, price)
                array.push(kl_swing_price, swing_ref)
                array.push(kl_side, side)
                array.push(kl_strength, strength)
                array.push(kl_peak_ratio, ratio)
                array.push(kl_avg_ratio, ratio)
                array.push(kl_poc_volume, total_vol)
                array.push(kl_net_delta, delta)
                array.push(kl_total_volume, total_vol)
                array.push(kl_tier, tier)
                array.push(kl_origin_bar, bar_index)
                array.push(kl_state, STATE_ACTIVE)
                array.push(kl_test_count, 0)
                array.push(kl_last_test_bar, 0)
                array.push(kl_entry_price, na)
                array.push(kl_stop_price, na)
                array.push(kl_target_price, na)
                array.push(kl_rr_ratio, na)
                array.push(kl_outcome, "")
                array.push(kl_realized_ticks, na)
                // Initialize line/label IDs as na (uninitialized)
                array.push(kl_entry_line, na)
                array.push(kl_stop_line, na)
                array.push(kl_target_line, na)
                array.push(kl_trade_label, na)
                array.push(kl_reject_count, 0)
                array.push(kl_break_bars, 0)
                array.push(kl_poc_tagged, false)
                array.push(kl_closed_logged, false)

                // Setup Generator: seed a new setup for this key level
                string setup_dir = side == "buy" ? "long" : "short"
                float setup_entry = price
                float setup_zone_top = range_top
                float setup_zone_bottom = range_bottom
                float setup_poc = price
                float setup_strength = strength

                // Stop/target sizing using ATR and min/max tick guards
                float base_stop = setup_dir == "long" ? setup_zone_bottom : setup_zone_top
                float atr_stop = setup_dir == "long" ? setup_entry - (atr * atrMult) : setup_entry + (atr * atrMult)
                float raw_stop = setup_dir == "long" ? math.min(base_stop, atr_stop) : math.max(base_stop, atr_stop)
                float risk_ticks = math.abs(setup_entry - raw_stop) / syminfo.mintick
                float clamped_ticks = math.min(math.max(risk_ticks, minStopTicks), maxStopTicks)
                float setup_stop = setup_dir == "long" ? setup_entry - (clamped_ticks * syminfo.mintick) : setup_entry + (clamped_ticks * syminfo.mintick)

                // 1R scalp target based on clamped risk distance
                float setup_scalp = setup_dir == "long" ? setup_entry + (clamped_ticks * syminfo.mintick) : setup_entry - (clamped_ticks * syminfo.mintick)

                // Runner target: nearest opposing imbalance POC
                string opp_side = setup_dir == "long" ? "sell" : "buy"
                float setup_runner = na
                float nearest_diff = na
                int kl_count_runner = array.size(kl_poc)
                if kl_count_runner > 0
                    for rr = 0 to kl_count_runner - 1
                        string rr_side = array.get(kl_side, rr)
                        float rr_poc = array.get(kl_poc, rr)
                        if rr_side == opp_side and not na(rr_poc)
                            float diff = math.abs(rr_poc - setup_entry)
                            if na(nearest_diff) or diff < nearest_diff
                                nearest_diff := diff
                                setup_runner := rr_poc

                array.push(setup_entryPrice, setup_entry)
                array.push(setup_stopPrice, setup_stop)
                array.push(setup_scalpTarget, setup_scalp)
                array.push(setup_runnerTarget, setup_runner)
                array.push(setup_direction, setup_dir)
                array.push(setup_zoneTop, setup_zone_top)
                array.push(setup_zoneBottom, setup_zone_bottom)
                array.push(setup_pocPrice, setup_poc)
                array.push(setup_strengthScore, setup_strength)
                array.push(setup_state, SETUP_READY)
                array.push(setup_pocConfirm, 0)
                array.push(setup_stopConfirm, 0)
                array.push(setup_scalpConfirm, 0)
                array.push(setup_runnerConfirm, 0)

                color box_color = side == "buy" ? color.new(col_buy, 70) : color.new(col_sell, 70)
                box new_box = box.new(left=bar_index, top=range_top, right=bar_index + 1, bottom=range_bottom, border_color=box_color, bgcolor=box_color, border_width=1)
                array.push(kl_box, new_box)
                array.push(trade_state, TE_STATE_ACTIVE)
                array.push(trade_opened, false)
                array.push(trade_entry, na)
                array.push(trade_stop, na)
                array.push(trade_target, na)
                array.push(trade_ticks, na)
                array.push(trade_entry_bar, na)
                array.push(trade_created_bar, na)
                array.push(trade_closed_bar, na)

                // Immediately build a trade setup for this new key level.
                // This uses the unified swing+ATR stop and RR-banded target logic.
                int new_idx = array.size(kl_state) - 1

                int updated_seq = create_trade_for_level(new_idx, trade_seq)
                bool created_setup = updated_seq != trade_seq
                trade_seq := updated_seq

                float kl_entry = new_idx < array.size(kl_entry_price) ? array.get(kl_entry_price, new_idx) : na
                float kl_stop = new_idx < array.size(kl_stop_price) ? array.get(kl_stop_price, new_idx) : na
                float kl_take = new_idx < array.size(kl_target_price) ? array.get(kl_target_price, new_idx) : na
                log_timeline("KL detected", side == "buy" ? "Buy" : "Sell", kl_entry, kl_stop, kl_take, na, na)

                // If creation failed (no valid swing, zero risk, etc), leave the level in STATE_ACTIVE
                // with empty prices so that the ACTIVE ? ENTRY logic can try again on a later touch.
                if not created_setup
                    array.set(kl_last_test_bar, new_idx, bar_index)
    
    // Sort by tier then strength
    if array.size(kl_strength) > 1
        int n = array.size(kl_strength)
        for i = 0 to n - 2
            for j = 0 to n - 2 - i
                string tier_j = array.get(kl_tier, j)
                string tier_j1 = array.get(kl_tier, j + 1)
                int rank_j = get_tier_rank(tier_j)
                int rank_j1 = get_tier_rank(tier_j1)
                
                bool should_swap = false
                if rank_j < rank_j1
                    should_swap := true
                else if rank_j == rank_j1 and array.get(kl_strength, j) < array.get(kl_strength, j + 1)
                    should_swap := true
                
                if should_swap
                    // Swap all arrays (keeping it compact)
                    float tmp_f = array.get(kl_range_top, j)
                    array.set(kl_range_top, j, array.get(kl_range_top, j + 1))
                    array.set(kl_range_top, j + 1, tmp_f)
                    
                    tmp_f := array.get(kl_range_bottom, j)
                    array.set(kl_range_bottom, j, array.get(kl_range_bottom, j + 1))
                    array.set(kl_range_bottom, j + 1, tmp_f)
                    
                    tmp_f := array.get(kl_poc, j)
                    array.set(kl_poc, j, array.get(kl_poc, j + 1))
                    array.set(kl_poc, j + 1, tmp_f)

                    tmp_f := array.get(kl_swing_price, j)
                    array.set(kl_swing_price, j, array.get(kl_swing_price, j + 1))
                    array.set(kl_swing_price, j + 1, tmp_f)

                    string tmp_s = array.get(kl_side, j)
                    array.set(kl_side, j, array.get(kl_side, j + 1))
                    array.set(kl_side, j + 1, tmp_s)
                    
                    tmp_f := array.get(kl_strength, j)
                    array.set(kl_strength, j, array.get(kl_strength, j + 1))
                    array.set(kl_strength, j + 1, tmp_f)
                    
                    tmp_f := array.get(kl_peak_ratio, j)
                    array.set(kl_peak_ratio, j, array.get(kl_peak_ratio, j + 1))
                    array.set(kl_peak_ratio, j + 1, tmp_f)
                    
                    tmp_f := array.get(kl_avg_ratio, j)
                    array.set(kl_avg_ratio, j, array.get(kl_avg_ratio, j + 1))
                    array.set(kl_avg_ratio, j + 1, tmp_f)

                    tmp_f := array.get(kl_poc_volume, j)
                    array.set(kl_poc_volume, j, array.get(kl_poc_volume, j + 1))
                    array.set(kl_poc_volume, j + 1, tmp_f)

                    tmp_f := array.get(kl_net_delta, j)
                    array.set(kl_net_delta, j, array.get(kl_net_delta, j + 1))
                    array.set(kl_net_delta, j + 1, tmp_f)

                    tmp_f := array.get(kl_total_volume, j)
                    array.set(kl_total_volume, j, array.get(kl_total_volume, j + 1))
                    array.set(kl_total_volume, j + 1, tmp_f)

                    tmp_s := array.get(kl_tier, j)
                    array.set(kl_tier, j, array.get(kl_tier, j + 1))
                    array.set(kl_tier, j + 1, tmp_s)
                    
                    int tmp_i = array.get(kl_origin_bar, j)
                    array.set(kl_origin_bar, j, array.get(kl_origin_bar, j + 1))
                    array.set(kl_origin_bar, j + 1, tmp_i)
                    
                    tmp_s := array.get(kl_state, j)
                    array.set(kl_state, j, array.get(kl_state, j + 1))
                    array.set(kl_state, j + 1, tmp_s)
                    
                    tmp_i := array.get(kl_test_count, j)
                    array.set(kl_test_count, j, array.get(kl_test_count, j + 1))
                    array.set(kl_test_count, j + 1, tmp_i)
                    
                    tmp_i := array.get(kl_last_test_bar, j)
                    array.set(kl_last_test_bar, j, array.get(kl_last_test_bar, j + 1))
                    array.set(kl_last_test_bar, j + 1, tmp_i)

                    tmp_s := array.get(kl_outcome, j)
                    array.set(kl_outcome, j, array.get(kl_outcome, j + 1))
                    array.set(kl_outcome, j + 1, tmp_s)

                    tmp_f := array.get(kl_realized_ticks, j)
                    array.set(kl_realized_ticks, j, array.get(kl_realized_ticks, j + 1))
                    array.set(kl_realized_ticks, j + 1, tmp_f)
                    
                    box tmp_box = array.get(kl_box, j)
                    array.set(kl_box, j, array.get(kl_box, j + 1))
                    array.set(kl_box, j + 1, tmp_box)
                    
                    tmp_f := array.get(kl_entry_price, j)
                    array.set(kl_entry_price, j, array.get(kl_entry_price, j + 1))
                    array.set(kl_entry_price, j + 1, tmp_f)
                    
                    tmp_f := array.get(kl_stop_price, j)
                    array.set(kl_stop_price, j, array.get(kl_stop_price, j + 1))
                    array.set(kl_stop_price, j + 1, tmp_f)
                    
                    tmp_f := array.get(kl_target_price, j)
                    array.set(kl_target_price, j, array.get(kl_target_price, j + 1))
                    array.set(kl_target_price, j + 1, tmp_f)
                    
                    tmp_f := array.get(kl_rr_ratio, j)
                    array.set(kl_rr_ratio, j, array.get(kl_rr_ratio, j + 1))
                    array.set(kl_rr_ratio, j + 1, tmp_f)
                    
                    line tmp_line = array.get(kl_entry_line, j)
                    array.set(kl_entry_line, j, array.get(kl_entry_line, j + 1))
                    array.set(kl_entry_line, j + 1, tmp_line)
                    
                    tmp_line := array.get(kl_stop_line, j)
                    array.set(kl_stop_line, j, array.get(kl_stop_line, j + 1))
                    array.set(kl_stop_line, j + 1, tmp_line)
                    
                    tmp_line := array.get(kl_target_line, j)
                    array.set(kl_target_line, j, array.get(kl_target_line, j + 1))
                    array.set(kl_target_line, j + 1, tmp_line)
                    
                    label tmp_label = array.get(kl_trade_label, j)
                    array.set(kl_trade_label, j, array.get(kl_trade_label, j + 1))
                    array.set(kl_trade_label, j + 1, tmp_label)
                    
                    tmp_i := array.get(kl_reject_count, j)
                    array.set(kl_reject_count, j, array.get(kl_reject_count, j + 1))
                    array.set(kl_reject_count, j + 1, tmp_i)

                    tmp_i := array.get(kl_break_bars, j)
                    array.set(kl_break_bars, j, array.get(kl_break_bars, j + 1))
                    array.set(kl_break_bars, j + 1, tmp_i)

                    bool tmp_tag = array.get(kl_poc_tagged, j)
                    array.set(kl_poc_tagged, j, array.get(kl_poc_tagged, j + 1))
                    array.set(kl_poc_tagged, j + 1, tmp_tag)

                    tmp_i := array.get(trade_state, j)
                    array.set(trade_state, j, array.get(trade_state, j + 1))
                    array.set(trade_state, j + 1, tmp_i)

                    bool tmp_open = array.get(trade_opened, j)
                    array.set(trade_opened, j, array.get(trade_opened, j + 1))
                    array.set(trade_opened, j + 1, tmp_open)

                    tmp_i := array.get(trade_entry_bar, j)
                    array.set(trade_entry_bar, j, array.get(trade_entry_bar, j + 1))
                    array.set(trade_entry_bar, j + 1, tmp_i)

                    tmp_i := array.get(trade_closed_bar, j)
                    array.set(trade_closed_bar, j, array.get(trade_closed_bar, j + 1))
                    array.set(trade_closed_bar, j + 1, tmp_i)

                    bool tmp_b = array.get(kl_closed_logged, j)
                    array.set(kl_closed_logged, j, array.get(kl_closed_logged, j + 1))
                    array.set(kl_closed_logged, j + 1, tmp_b)

                    tmp_f := array.get(trade_entry, j)
                    array.set(trade_entry, j, array.get(trade_entry, j + 1))
                    array.set(trade_entry, j + 1, tmp_f)

                    tmp_f := array.get(trade_stop, j)
                    array.set(trade_stop, j, array.get(trade_stop, j + 1))
                    array.set(trade_stop, j + 1, tmp_f)

                    tmp_f := array.get(trade_target, j)
                    array.set(trade_target, j, array.get(trade_target, j + 1))
                    array.set(trade_target, j + 1, tmp_f)

                    tmp_f := array.get(trade_ticks, j)
                    array.set(trade_ticks, j, array.get(trade_ticks, j + 1))
                    array.set(trade_ticks, j + 1, tmp_f)

                    tmp_i := array.get(trade_created_bar, j)
                    array.set(trade_created_bar, j, array.get(trade_created_bar, j + 1))
                    array.set(trade_created_bar, j + 1, tmp_i)

                    swap_trade_indices(j, j + 1)
        
        while array.size(kl_strength) > maxKeyLevels
            int drop_idx = array.size(kl_entry_line) - 1
            if not na(array.get(kl_entry_line, drop_idx))
                line.delete(array.get(kl_entry_line, drop_idx))
            if not na(array.get(kl_stop_line, drop_idx))
                line.delete(array.get(kl_stop_line, drop_idx))
            if not na(array.get(kl_target_line, drop_idx))
                line.delete(array.get(kl_target_line, drop_idx))
            if not na(array.get(kl_trade_label, drop_idx))
                label.delete(array.get(kl_trade_label, drop_idx))
            box.delete(array.get(kl_box, drop_idx))

            remove_trades_for_index(drop_idx)

            array.pop(kl_range_top)
            array.pop(kl_range_bottom)
            array.pop(kl_poc)
            array.pop(kl_swing_price)
            array.pop(kl_side)
            array.pop(kl_strength)
            array.pop(kl_peak_ratio)
            array.pop(kl_avg_ratio)
            array.pop(kl_poc_volume)
            array.pop(kl_net_delta)
            array.pop(kl_total_volume)
            array.pop(kl_tier)
            array.pop(kl_origin_bar)
            array.pop(kl_state)
            array.pop(kl_test_count)
            array.pop(kl_last_test_bar)
            array.pop(kl_outcome)
            array.pop(kl_realized_ticks)
            array.pop(kl_box)
            array.pop(kl_entry_price)
            array.pop(kl_stop_price)
            array.pop(kl_target_price)
            array.pop(kl_rr_ratio)
            array.pop(kl_entry_line)
            array.pop(kl_stop_line)
            array.pop(kl_target_line)
            array.pop(kl_trade_label)
            array.pop(kl_reject_count)
            array.pop(kl_break_bars)
            array.pop(kl_poc_tagged)
            array.pop(trade_state)
            array.pop(trade_opened)
            array.pop(trade_entry)
            array.pop(trade_stop)
            array.pop(trade_target)
            array.pop(trade_ticks)
            array.pop(trade_entry_bar)
            array.pop(trade_created_bar)
            array.pop(trade_closed_bar)
            array.pop(kl_closed_logged)

// ============================================================================
// LIFECYCLE UPDATE WITH ENTRY STATUS AND TRADE SETUP
// ============================================================================

if array.size(kl_state) > 0
    for i = 0 to array.size(kl_state) - 1
        if i < array.size(kl_state)
            string current_state = array.get(kl_state, i)
            string side = array.get(kl_side, i)
            float range_top = array.get(kl_range_top, i)
            float range_bottom = array.get(kl_range_bottom, i)
            float poc = array.get(kl_poc, i)
            int test_count = array.get(kl_test_count, i)
            int last_test = array.get(kl_last_test_bar, i)
            int reject_count = array.get(kl_reject_count, i)
            int break_bars = array.get(kl_break_bars, i)
            bool poc_tagged = array.get(kl_poc_tagged, i)
            float wick_tolerance = wickToleranceTicks * syminfo.mintick

            float reject_buffer = rejectionBuffer * syminfo.mintick

            float entry_price_lvl = array.get(kl_entry_price, i)
            bool entry_defined = not na(entry_price_lvl)
            bool entry_touched = entry_defined and (high >= entry_price_lvl and low <= entry_price_lvl)

            bool poc_touched = not na(poc) and (high >= poc - wick_tolerance) and (low <= poc + wick_tolerance)
            if poc_touched and not poc_tagged
                poc_tagged := true

            bool in_buffered_zone = (high >= range_bottom - wick_tolerance) and (low <= range_top + wick_tolerance)
            bool outside_buffered_zone = (close > range_top + wick_tolerance) or (close < range_bottom - wick_tolerance)

            if in_buffered_zone
                break_bars := 0
            else if poc_tagged and outside_buffered_zone
                break_bars += 1

            array.set(kl_break_bars, i, break_bars)
            array.set(kl_poc_tagged, i, poc_tagged)

            bool eligible_reject_state = current_state == STATE_ACTIVE or current_state == STATE_ENTRY or current_state == STATE_TESTING
            bool should_reject_zone = eligible_reject_state and poc_tagged and entry_touched and break_bars >= zoneConfirmBars

            if should_reject_zone
                array.set(kl_state, i, STATE_REJECTED)
                if i < array.size(trade_state)
                    array.set(trade_state, i, TE_STATE_REJECTED)
                array.set(kl_outcome, i, "Rejected")

            current_state := array.get(kl_state, i)

            if i < array.size(trade_state) and array.get(trade_state, i) == TE_STATE_POSSIBLE
                int created_bar = i < array.size(trade_created_bar) ? array.get(trade_created_bar, i) : na
                if not na(created_bar)
                    if bar_index - created_bar > expireBars
                        array.set(trade_state, i, TE_STATE_REJECTED)
                        if i < array.size(kl_state)
                            array.set(kl_state, i, STATE_REJECTED)

            if current_state == STATE_PROFIT or current_state == STATE_LOSS
                int ts_closed = i < array.size(trade_state) ? array.get(trade_state, i) : na
                bool trade_live = ts_closed == TE_STATE_OPEN
                bool already_closed = i < array.size(trade_closed_bar) and not na(array.get(trade_closed_bar, i))
                float entry_price = array.get(kl_entry_price, i)
                float stop_price = array.get(kl_stop_price, i)
                float target_price = array.get(kl_target_price, i)
                bool has_exit = current_state == STATE_PROFIT ? not na(target_price) : not na(stop_price)
                if trade_live and not already_closed and not na(entry_price) and not na(stop_price) and has_exit
                    float exit_price = current_state == STATE_PROFIT ? target_price : stop_price
                    float ticks_val = side == "buy" ? (exit_price - entry_price) / syminfo.mintick : (entry_price - exit_price) / syminfo.mintick
                    finalize_close(i, current_state == STATE_PROFIT ? "Profit" : "Loss", ticks_val)

            // Setup Engine state machine
            float setup_wick_buffer = wickToleranceTicks * syminfo.mintick
            for si = 0 to array.size(setup_state) - 1
                string s_state = array.get(setup_state, si)
                string s_dir = si < array.size(setup_direction) ? array.get(setup_direction, si) : ""
                float s_entry = si < array.size(setup_entryPrice) ? array.get(setup_entryPrice, si) : na
                float s_zone_top = si < array.size(setup_zoneTop) ? array.get(setup_zoneTop, si) : na
                float s_zone_bottom = si < array.size(setup_zoneBottom) ? array.get(setup_zoneBottom, si) : na
                float s_poc = si < array.size(setup_pocPrice) ? array.get(setup_pocPrice, si) : na
                float s_stop = si < array.size(setup_stopPrice) ? array.get(setup_stopPrice, si) : na
                float s_scalp = si < array.size(setup_scalpTarget) ? array.get(setup_scalpTarget, si) : na
                float s_runner = si < array.size(setup_runnerTarget) ? array.get(setup_runnerTarget, si) : na
                float s_strength = si < array.size(setup_strengthScore) ? array.get(setup_strengthScore, si) : na

                int poc_confirm = si < array.size(setup_pocConfirm) ? array.get(setup_pocConfirm, si) : 0
                int stop_confirm = si < array.size(setup_stopConfirm) ? array.get(setup_stopConfirm, si) : 0
                int scalp_confirm = si < array.size(setup_scalpConfirm) ? array.get(setup_scalpConfirm, si) : 0
                int runner_confirm = si < array.size(setup_runnerConfirm) ? array.get(setup_runnerConfirm, si) : 0

                // Stronger opposing imbalance invalidates this setup
                string opp_side = s_dir == "long" ? "sell" : "buy"
                bool stronger_opp = false
                int last_idx = array.size(kl_strength) - 1
                if last_idx >= 0
                    string last_side = array.get(kl_side, last_idx)
                    int last_origin = array.get(kl_origin_bar, last_idx)
                    float last_strength = array.get(kl_strength, last_idx)
                    if last_side == opp_side and last_origin == bar_index and (na(s_strength) or last_strength > s_strength)
                        stronger_opp := true

                if stronger_opp
                    array.set(setup_state, si, INVALIDATED)
                    if si < array.size(setup_pocConfirm)
                        array.set(setup_pocConfirm, si, 0)
                    if si < array.size(setup_stopConfirm)
                        array.set(setup_stopConfirm, si, 0)
                    if si < array.size(setup_scalpConfirm)
                        array.set(setup_scalpConfirm, si, 0)
                    if si < array.size(setup_runnerConfirm)
                        array.set(setup_runnerConfirm, si, 0)
                    s_state := INVALIDATED

                switch s_state
                    "SETUP_READY" =>
                        bool in_zone_ready = not na(s_zone_top) and not na(s_zone_bottom) and (high >= s_zone_bottom - setup_wick_buffer) and (low <= s_zone_top + setup_wick_buffer)
                        if in_zone_ready
                            array.set(setup_state, si, WAITING_FOR_RETEST)
                            if si < array.size(setup_pocConfirm)
                                array.set(setup_pocConfirm, si, 0)
                            if si < array.size(setup_stopConfirm)
                                array.set(setup_stopConfirm, si, 0)
                            if si < array.size(setup_scalpConfirm)
                                array.set(setup_scalpConfirm, si, 0)
                            if si < array.size(setup_runnerConfirm)
                                array.set(setup_runnerConfirm, si, 0)
                    "WAITING_FOR_RETEST" =>
                        bool poc_touch = not na(s_poc) and (high >= s_poc - setup_wick_buffer) and (low <= s_poc + setup_wick_buffer)
                        poc_confirm := poc_touch ? poc_confirm + 1 : 0
                        if si < array.size(setup_pocConfirm)
                            array.set(setup_pocConfirm, si, poc_confirm)
                        if poc_confirm >= zoneConfirmBars
                            array.set(setup_state, si, OPEN_TRADE)
                            if si < array.size(setup_stopConfirm)
                                array.set(setup_stopConfirm, si, 0)
                            if si < array.size(setup_scalpConfirm)
                                array.set(setup_scalpConfirm, si, 0)
                            if si < array.size(setup_runnerConfirm)
                                array.set(setup_runnerConfirm, si, 0)
                    "OPEN_TRADE" =>
                        bool stop_touch = not na(s_stop) and ((s_dir == "long" and low <= s_stop + setup_wick_buffer) or (s_dir == "short" and high >= s_stop - setup_wick_buffer))
                        stop_confirm := stop_touch ? stop_confirm + 1 : 0
                        if si < array.size(setup_stopConfirm)
                            array.set(setup_stopConfirm, si, stop_confirm)

                        bool scalp_touch = not na(s_scalp) and ((s_dir == "long" and high >= s_scalp - setup_wick_buffer) or (s_dir == "short" and low <= s_scalp + setup_wick_buffer))
                        bool runner_touch = not na(s_runner) and ((s_dir == "long" and high >= s_runner - setup_wick_buffer) or (s_dir == "short" and low <= s_runner + setup_wick_buffer))

                        scalp_confirm := scalp_touch ? scalp_confirm + 1 : 0
                        runner_confirm := runner_touch ? runner_confirm + 1 : 0

                        if si < array.size(setup_scalpConfirm)
                            array.set(setup_scalpConfirm, si, scalp_confirm)
                        if si < array.size(setup_runnerConfirm)
                            array.set(setup_runnerConfirm, si, runner_confirm)

                        bool stop_hit = stop_confirm >= stopConfirmBars
                        bool scalp_hit = scalp_confirm >= profitConfirmBars
                        bool runner_hit = runner_confirm >= profitConfirmBars

                        if stop_hit
                            array.set(setup_state, si, INVALIDATED)
                            if si < array.size(setup_pocConfirm)
                                array.set(setup_pocConfirm, si, 0)
                            if si < array.size(setup_stopConfirm)
                                array.set(setup_stopConfirm, si, 0)
                            if si < array.size(setup_scalpConfirm)
                                array.set(setup_scalpConfirm, si, 0)
                            if si < array.size(setup_runnerConfirm)
                                array.set(setup_runnerConfirm, si, 0)
                        else if scalp_hit or runner_hit
                            array.set(setup_state, si, CLOSED_TRADE)
                            if si < array.size(setup_stopConfirm)
                                array.set(setup_stopConfirm, si, 0)
                            if si < array.size(setup_scalpConfirm)
                                array.set(setup_scalpConfirm, si, 0)
                            if si < array.size(setup_runnerConfirm)
                                array.set(setup_runnerConfirm, si, 0)
                    "CLOSED_TRADE" =>
                        // Trade has closed; retain for history/cleanup
                    "INVALIDATED" =>
                        // Setup invalidated; pending cleanup
            // Legacy trade engine transitions (disabled)
            if false
                if current_state == STATE_ACTIVE
                    bool has_setup = i < array.size(kl_entry_price) and not na(array.get(kl_entry_price, i))

                    if not has_setup
                        array.set(trade_state, i, TE_STATE_ACTIVE)
                        // Evaluate trade filters
                        // Compute the imbalance ratio and total volume for this level
                        float ratio_i = array.get(kl_peak_ratio, i)
                        float totalVol = array.get(kl_poc_volume, i)
                        // Estimate opposing volume: for buy levels ratio = buy/sell, so sellVol  totalVol/(1+ratio).
                        // For sell levels ratio = sell/buy, so buyVol  totalVol/(1+ratio).
                        float opposingVol = totalVol / (1 + ratio_i)
                        float opposingPct = totalVol > 0 ? opposingVol / totalVol : 1.0
                        bool opposition_ok = opposingPct <= maxOpposingPct or ratio_i >= imbalanceRatio
                        bool trendAlign = not trendFilterEnabled or ((side == "buy" and trendDir == "up") or (side == "sell" and trendDir == "down"))
                        bool extremeLevel = ratio_i >= extremeRatio
                        int tier_rank = get_tier_rank(array.get(kl_tier, i))
                        float strength = array.get(kl_strength, i)
                        float entryPrice = array.get(kl_entry_price, i)
                        float distance = math.abs(close - entryPrice)
                        bool qualityOK = tier_rank >= 2 and strength >= minStrength and distance <= maxDistanceTicks * syminfo.mintick
                        // A level passes the filter if it aligns with the prevailing trend
                        // and either meets the opposing-volume threshold or already clears
                        // the baseline imbalance ratio. Extreme tiers still override both.
                        bool passFilter = (not trendFilterEnabled or (trendAlign and (opposition_ok or extremeLevel)) or extremeLevel) and qualityOK

                        if passFilter
                            // Use the unified swing+ATR stop and RR-banded targeting helper
                            int seq_after_create = create_trade_for_level(i, trade_seq)
                            bool created = seq_after_create != trade_seq
                            trade_seq := seq_after_create
                            if not created
                                array.set(kl_last_test_bar, i, bar_index)
                        else
                            // Filters not satisfied  remain ACTIVE and record touch
                            array.set(kl_last_test_bar, i, bar_index)

                // ENTRY ? TESTING (trade is live)
                else if current_state == STATE_ENTRY
                    trade_seq := register_set_trade(i, trade_seq)
                    float entry_price = array.get(kl_entry_price, i)
                    bool has_prices = not na(entry_price) and i < array.size(kl_stop_price) and not na(array.get(kl_stop_price, i)) and i < array.size(kl_target_price) and not na(array.get(kl_target_price, i))
                    bool triggered = has_prices and (side == "buy" ? (low <= entry_price) : (high >= entry_price))

                    if triggered and not has_open_trade()
                        open_trade_for_level(i)
                        process_open_trade_bar(i, side)

                // TESTING ? PROFIT or LOSS
                else if current_state == STATE_TESTING
                    process_open_trade_bar(i, side)

                // PROFIT ? HELD
                else if current_state == STATE_PROFIT
                    if test_count >= 2
                        array.set(kl_state, i, STATE_HELD)

                    // Check for retouch
                    bool touching_again = (low <= range_top) and (high >= range_bottom)
                    if touching_again and (bar_index > last_test + 3)
                        // Retouch entries share the same stop/target sizing as first touches
                        int seq_after_create = create_trade_for_level(i, trade_seq)
                        bool created = seq_after_create != trade_seq
                        trade_seq := seq_after_create
                        if not created
                            array.set(kl_last_test_bar, i, bar_index)

                // HELD
                else if current_state == STATE_HELD
                    bool touching_again = (low <= range_top) and (high >= range_bottom)
                    if touching_again and (bar_index > last_test + 3)
                        // Re-engage held levels with the unified trade creation rules
                        int seq_after_create = create_trade_for_level(i, trade_seq)
                        bool created = seq_after_create != trade_seq
                        trade_seq := seq_after_create
                        if not created
                            array.set(kl_last_test_bar, i, bar_index)

// ---------------------------------------------------------------------------
// Dev debug overlay for the most recent trade candidate
if barstate.islast
    if showDebug and array.size(trade_state) > 0
        int latest_idx = na
        for idx = array.size(trade_state) - 1 to 0
            int ts = array.get(trade_state, idx)
            if ts == TE_STATE_POSSIBLE or ts == TE_STATE_OPEN
                latest_idx := idx
                break

        if not na(latest_idx) and latest_idx < array.size(kl_entry_price) and latest_idx < array.size(kl_stop_price) and latest_idx < array.size(kl_target_price) and latest_idx < array.size(kl_rr_ratio) and latest_idx < array.size(kl_side)
            float entry = array.get(kl_entry_price, latest_idx)
            float stop = array.get(kl_stop_price, latest_idx)
            float target = array.get(kl_target_price, latest_idx)
            float rr = array.get(kl_rr_ratio, latest_idx)

            if not na(entry) and not na(stop) and not na(target) and not na(rr)
                int x1 = bar_index - 1
                int x2 = bar_index

                if na(debugEntryLine)
                    debugEntryLine := line.new(x1, entry, x2, entry, color=color.new(color.silver, 40), width=1, style=line.style_solid)
                else
                    line.set_xy1(debugEntryLine, x1, entry)
                    line.set_xy2(debugEntryLine, x2, entry)
                    line.set_color(debugEntryLine, color.new(color.silver, 40))

                if na(debugStopLine)
                    debugStopLine := line.new(x1, stop, x2, stop, color=color.new(col_stop, 20), width=1, style=line.style_solid)
                else
                    line.set_xy1(debugStopLine, x1, stop)
                    line.set_xy2(debugStopLine, x2, stop)
                    line.set_color(debugStopLine, color.new(col_stop, 20))

                if na(debugTargetLine)
                    debugTargetLine := line.new(x1, target, x2, target, color=color.new(col_target, 20), width=1, style=line.style_solid)
                else
                    line.set_xy1(debugTargetLine, x1, target)
                    line.set_xy2(debugTargetLine, x2, target)
                    line.set_color(debugTargetLine, color.new(col_target, 20))

                float riskTicks = math.round(math.abs(entry - stop) / syminfo.mintick * 10.0) / 10.0
                float rrRounded = math.round(rr * 10.0) / 10.0
                string side_val = array.get(kl_side, latest_idx)
                float levelTarget = find_next_target(latest_idx, side_val)
                string source = (not na(levelTarget) and math.abs(levelTarget - target) <= 0.5 * syminfo.mintick) ? "Level" : "Synthetic"

                if na(debugLabel)
                    debugLabel := label.new(bar_index, entry, "", color=color.new(color.gray, 85), textcolor=color.white, style=label.style_label_left, size=size.small)
                else
                    label.set_x(debugLabel, bar_index)
                    label.set_y(debugLabel, entry)

                label.set_text(debugLabel, "Risk: " + str.tostring(riskTicks) + "t\nRR: " + str.tostring(rrRounded) + " (" + source + ")")
            else
                if not na(debugEntryLine)
                    line.delete(debugEntryLine)
                    debugEntryLine := na
                if not na(debugStopLine)
                    line.delete(debugStopLine)
                    debugStopLine := na
                if not na(debugTargetLine)
                    line.delete(debugTargetLine)
                    debugTargetLine := na
                if not na(debugLabel)
                    label.delete(debugLabel)
                    debugLabel := na
        else
            if not na(debugEntryLine)
                line.delete(debugEntryLine)
                debugEntryLine := na
            if not na(debugStopLine)
                line.delete(debugStopLine)
                debugStopLine := na
            if not na(debugTargetLine)
                line.delete(debugTargetLine)
                debugTargetLine := na
            if not na(debugLabel)
                label.delete(debugLabel)
                debugLabel := na
    else
        if not na(debugEntryLine)
            line.delete(debugEntryLine)
            debugEntryLine := na
        if not na(debugStopLine)
            line.delete(debugStopLine)
            debugStopLine := na
        if not na(debugTargetLine)
            line.delete(debugTargetLine)
            debugTargetLine := na
        if not na(debugLabel)
            label.delete(debugLabel)
            debugLabel := na

// ============================================================================
// RENDERING - BOXES AND TRADE LINES
// ============================================================================

if array.size(kl_box) > 0
    for i = 0 to array.size(kl_box) - 1
        if i < array.size(kl_box) and i < array.size(kl_state)
            box current_box = array.get(kl_box, i)
            string state = array.get(kl_state, i)
            string side = array.get(kl_side, i)
            string tier = array.get(kl_tier, i)
            
            color base_color = side == "buy" ? col_buy : col_sell
            
            // Box rendering
            if showBoxes
                int base_opacity = 70
                if state == STATE_ACTIVE
                    base_opacity := 70
                else if state == STATE_ENTRY
                    base_opacity := 40  // Brighter - trade setup ready!
                else if state == STATE_TESTING
                    base_opacity := 50
                else if state == STATE_PROFIT
                    base_opacity := 30
                else if state == STATE_HELD
                    base_opacity := 20
                else
                    base_opacity := 90
                
                int tier_boost = tier == TIER_EXTREME ? 10 : tier == TIER_STRONG ? 5 : 0
                int final_opacity = math.max(10, base_opacity - tier_boost)
                
                box.set_right(current_box, bar_index + 1)
                box.set_border_color(current_box, color.new(base_color, final_opacity))
                box.set_bgcolor(current_box, color.new(base_color, final_opacity))
            
            // Trade line rendering
            if showTradeLines
                float entry = array.get(kl_entry_price, i)
                float stop = array.get(kl_stop_price, i)
                float target = array.get(kl_target_price, i)
                float rr = array.get(kl_rr_ratio, i)
                
                // Draw/update lines for ENTRY or TESTING states
                if (state == STATE_ENTRY or state == STATE_TESTING) and not na(entry) and not na(stop) and not na(target)
                    // Entry line
                    line entry_line = array.get(kl_entry_line, i)
                    if na(entry_line)
                        entry_line := line.new(bar_index, entry, bar_index + 1, entry, color = base_color, width = 2, style = line.style_solid)
                        array.set(kl_entry_line, i, entry_line)
                    else
                        line.set_x2(entry_line, bar_index + 1)

                    // Stop line
                    line stop_line = array.get(kl_stop_line, i)
                    if na(stop_line)
                        stop_line := line.new(bar_index, stop, bar_index + 1, stop, color = col_stop, width = 2, style = line.style_dashed)
                        array.set(kl_stop_line, i, stop_line)
                    else
                        line.set_x2(stop_line, bar_index + 1)

                    // Target line
                    line target_line = array.get(kl_target_line, i)
                    if na(target_line)
                        target_line := line.new(bar_index, target, bar_index + 1, target, color = col_target, width = 2, style = line.style_dotted)
                        array.set(kl_target_line, i, target_line)
                    else
                        line.set_x2(target_line, bar_index + 1)

                    // Label with RR
                    label trade_label = array.get(kl_trade_label, i)
                    if na(trade_label)
                        string label_text = str.tostring(rr, "#.#") + ":1"
                        trade_label := label.new(bar_index, entry, label_text, color = color.new(base_color, 80), textcolor = color.white, style = label.style_label_left, size = size.small)
                        array.set(kl_trade_label, i, trade_label)
                    else
                        label.set_x(trade_label, bar_index)
                
                // Add outcome marker for PROFIT
                else if state == STATE_PROFIT and not na(entry)
                    label trade_label = array.get(kl_trade_label, i)
                    if na(trade_label)
                        trade_label := label.new(bar_index, entry, "?", color = color.new(color.lime, 70), textcolor = color.white, style = label.style_label_up, size = size.normal)
                        array.set(kl_trade_label, i, trade_label)
                
                // Add outcome marker for LOSS
                else if state == STATE_LOSS and not na(entry)
                    label trade_label = array.get(kl_trade_label, i)
                    if na(trade_label)
                        trade_label := label.new(bar_index, entry, "?", color = color.new(color.red, 70), textcolor = color.white, style = label.style_label_down, size = size.normal)
                        array.set(kl_trade_label, i, trade_label)

                else if state == STATE_CLOSED
                    if i < array.size(kl_closed_logged) and not array.get(kl_closed_logged, i)
                        record_closed_trade(i)
                    line entry_line = array.get(kl_entry_line, i)
                    if not na(entry_line)
                        line.delete(entry_line)
                        array.set(kl_entry_line, i, na)
                    line stop_line = array.get(kl_stop_line, i)
                    if not na(stop_line)
                        line.delete(stop_line)
                        array.set(kl_stop_line, i, na)
                    line target_line = array.get(kl_target_line, i)
                    if not na(target_line)
                        line.delete(target_line)
                        array.set(kl_target_line, i, na)
                    label trade_label = array.get(kl_trade_label, i)
                    if na(trade_label) and not na(entry)
                        string marker = array.get(kl_outcome, i) == "Profit" ? "?" : "?"
                        trade_label := label.new(bar_index, entry, marker, color = color.new(color.gray, 75), textcolor = color.white, style = label.style_label_left, size = size.small)
                        array.set(kl_trade_label, i, trade_label)
                
                // Add outcome marker for REJECTED (never triggered)
                else if state == STATE_REJECTED and not na(entry)
                    label trade_label = array.get(kl_trade_label, i)
                    if na(trade_label)
                        trade_label := label.new(bar_index, entry, "R", color = color.new(color.gray, 70), textcolor = color.white, style = label.style_label_down, size = size.normal)
                        array.set(kl_trade_label, i, trade_label)

// Closed-trade visual overlays
if array.size(closed_trade_boxes) > 0
    color hidden_col = color.new(color.white, 100)
    for i = 0 to array.size(closed_trade_boxes) - 1
        box bx = array.get(closed_trade_boxes, i)
        color box_col = showClosedTradeBoxes ? color.new(color.white, closedTradeBoxOpacity) : hidden_col
        box.set_bgcolor(bx, box_col)
        box.set_border_color(bx, box_col)

// On-chart visuals for the active open trade (TE_STATE_OPEN)
if not showTradeVisuals
    if not na(ot_entryLine)
        line.delete(ot_entryLine)
        ot_entryLine := na
    if not na(ot_stopLine)
        line.delete(ot_stopLine)
        ot_stopLine := na
    if not na(ot_targetLine)
        line.delete(ot_targetLine)
        ot_targetLine := na
    if not na(ot_riskBox)
        box.delete(ot_riskBox)
        ot_riskBox := na
    if not na(ot_rewardBox)
        box.delete(ot_rewardBox)
        ot_rewardBox := na
else
    bool has_active_open = false
    int openIdx = na
    if array.size(trade_state) > 0
        for oi = 0 to array.size(trade_state) - 1
            if array.get(trade_state, oi) == TE_STATE_OPEN
                openIdx := oi
                has_active_open := true
                break

    bool visuals_active = false
    if has_active_open and not na(openIdx)
        float open_entry = openIdx < array.size(trade_entry) ? array.get(trade_entry, openIdx) : na
        float open_stop = openIdx < array.size(kl_stop_price) ? array.get(kl_stop_price, openIdx) : na
        float open_target = openIdx < array.size(kl_target_price) ? array.get(kl_target_price, openIdx) : na
        string open_side = openIdx < array.size(kl_side) ? array.get(kl_side, openIdx) : ""

        bool have_prices = not na(open_entry) and not na(open_stop) and not na(open_target) and (open_side == "buy" or open_side == "sell")

        if have_prices
            visuals_active := true

            if na(ot_entryLine)
                ot_entryLine := line.new(bar_index, open_entry, bar_index, open_entry, extend = extend.right)
                line.set_width(ot_entryLine, 2)
            if na(ot_stopLine)
                ot_stopLine := line.new(bar_index, open_stop, bar_index, open_stop, extend = extend.right)
                line.set_width(ot_stopLine, 2)
            if na(ot_targetLine)
                ot_targetLine := line.new(bar_index, open_target, bar_index, open_target, extend = extend.right)
                line.set_width(ot_targetLine, 2)

            line.set_xy1(ot_entryLine, bar_index - 1, open_entry)
            line.set_xy2(ot_entryLine, bar_index, open_entry)
            line.set_color(ot_entryLine, color.new(color.white, 0))
            line.set_style(ot_entryLine, line.style_solid)

            line.set_xy1(ot_stopLine, bar_index - 1, open_stop)
            line.set_xy2(ot_stopLine, bar_index, open_stop)
            line.set_color(ot_stopLine, open_side == "buy" ? color.red : color.green)
            line.set_style(ot_stopLine, line.style_solid)

            line.set_xy1(ot_targetLine, bar_index - 1, open_target)
            line.set_xy2(ot_targetLine, bar_index, open_target)
            line.set_color(ot_targetLine, open_side == "buy" ? color.green : color.red)
            line.set_style(ot_targetLine, line.style_solid)

            if na(ot_riskBox)
                ot_riskBox := box.new(bar_index, open_entry, bar_index, open_stop)
            if na(ot_rewardBox)
                ot_rewardBox := box.new(bar_index, open_entry, bar_index, open_target)

            int bn = bar_index
            int future = bar_index + 30

            float risk_top = open_side == "buy" ? open_entry : open_stop
            float risk_bottom = open_side == "buy" ? open_stop : open_entry
            float reward_top = open_side == "buy" ? open_target : open_entry
            float reward_bottom = open_side == "buy" ? open_entry : open_target

            box.set_lefttop(ot_riskBox, bn - 1, risk_top)
            box.set_rightbottom(ot_riskBox, future, risk_bottom)
            box.set_bgcolor(ot_riskBox, color.new(color.red, 85))
            box.set_border_color(ot_riskBox, color.new(color.red, 85))

            box.set_lefttop(ot_rewardBox, bn - 1, reward_top)
            box.set_rightbottom(ot_rewardBox, future, reward_bottom)
            box.set_bgcolor(ot_rewardBox, color.new(color.green, 85))
            box.set_border_color(ot_rewardBox, color.new(color.green, 85))

    if not visuals_active
        if not na(ot_entryLine)
            line.delete(ot_entryLine)
            ot_entryLine := na
        if not na(ot_stopLine)
            line.delete(ot_stopLine)
            ot_stopLine := na
        if not na(ot_targetLine)
            line.delete(ot_targetLine)
            ot_targetLine := na
        if not na(ot_riskBox)
            box.delete(ot_riskBox)
            ot_riskBox := na
        if not na(ot_rewardBox)
            box.delete(ot_rewardBox)
            ot_rewardBox := na

// Trade visuals based on lifecycle arrays
if not showTradeVisuals
    clear_trade_visuals()
else
    if array.size(trades_set) > 0
        for i = 0 to array.size(trades_set) - 1
            Trade t = f_safe_get(trades_set, i)
            if not na(t)
                ensure_trade_visual(t, "set")

    if array.size(trades_open) > 0
        for i = 0 to array.size(trades_open) - 1
            Trade t = f_safe_get(trades_open, i)
            if not na(t)
                ensure_trade_visual(t, "open")

    if array.size(trades_closed) > 0
        for i = 0 to array.size(trades_closed) - 1
            Trade t = f_safe_get(trades_closed, i)
            if not na(t)
                ensure_trade_visual(t, "closed")

f_clear_table(tbl, int cols, int rows) =>
    if not na(tbl)
        if cols > 0 and rows > 0
            table.clear(tbl, 0, 0, cols - 1, rows - 1)

f_manage_table(tbl, enabled, pos, cols, rows, bg, border_width) =>
    table result = tbl
    if not enabled
        f_clear_table(result, cols, rows)
        result := na
    else
        if na(result)
            result := table.new(position = pos, columns = cols, rows = rows, bgcolor = bg, frame_color = bg, frame_width = border_width, border_color = bg, border_width = border_width)
    result

// ============================================================================
// TABLES
// ============================================================================

var table tbl_key = na
var table tbl_flow = na
var table tbl_mobile = na
var bool table_mobile_mode = false
var bool table_mobile_mode_initialized = false

bool use_mobile_layout = mobileCompact
bool recreate_layout = not table_mobile_mode_initialized or table_mobile_mode != use_mobile_layout
table_mobile_mode := use_mobile_layout
table_mobile_mode_initialized := true

bool desktopTablesOn = showTables and not use_mobile_layout
bool mobileTablesOn = showTables and use_mobile_layout

if recreate_layout
    tbl_key := na
    tbl_flow := na
    tbl_mobile := na

// Layout gating: allow key levels, unified trade ideas/open trades, and order flow on both desktop and mobile when tables are enabled.
if desktopTablesOn
    tbl_key := f_manage_table(tbl_key, true, position.bottom_right, 5, 12, color.new(color.black, 80), 1)
    tbl_flow := f_manage_table(tbl_flow, true, position.top_right, 9, 22, color.new(color.black, 80), 1)
    tbl_mobile := f_manage_table(tbl_mobile, false, position.bottom_center, 4, 10, color.new(color.black, 80), 1)
else if mobileTablesOn
    tbl_key := f_manage_table(tbl_key, true, position.bottom_right, 5, 10, color.new(color.black, 80), 1)
    tbl_flow := f_manage_table(tbl_flow, true, position.top_right, 9, 22, color.new(color.black, 80), 1)
    tbl_mobile := f_manage_table(tbl_mobile, false, position.bottom_center, 4, 10, color.new(color.black, 80), 1)
    // placeholder mobile HUD disabled
    // unified table kept for open trades on mobile
else
    tbl_key := f_manage_table(tbl_key, false, position.bottom_right, 5, 12, color.new(color.black, 80), 1)
    tbl_flow := f_manage_table(tbl_flow, false, position.top_right, 9, 22, color.new(color.black, 80), 1)
    tbl_mobile := f_manage_table(tbl_mobile, false, position.bottom_center, 4, 10, color.new(color.black, 80), 1)

if showTables and not na(tbl_key)
    table.cell(tbl_key, 0, 0, "KEY IMBALANCE LEVELS", text_color=color.white, text_size=size.normal, bgcolor=color.new(color.gray, 50))
    table.merge_cells(tbl_key, 0, 0, 4, 0)

    table.cell(tbl_key, 0, 1, "Range", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 70))
    table.cell(tbl_key, 1, 1, "POC", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 70))
    table.cell(tbl_key, 2, 1, "Side", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 70))
    table.cell(tbl_key, 3, 1, "%", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 70))
    table.cell(tbl_key, 4, 1, "Score", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 70))

    int level_count = array.size(kl_poc)
    int key_rows = mobileCompact ? 10 : 12  // mobile trims the key levels grid to 10 rows vs 12 on desktop
    int key_data_rows = math.max(key_rows - 2, 0)
    int display_count = math.min(level_count, key_data_rows)
    var int[] kl_price_order = array.new_int()
    var float[] kl_poc_buffer = array.new_float()
    array.clear(kl_price_order)
    array.clear(kl_poc_buffer)

    // Build a descending-by-price ordering so rows stack from high to low
    if level_count > 0
        for i = 0 to level_count - 1
            float poc_val_src = f_safe_get(kl_poc, i)
            array.push(kl_poc_buffer, poc_val_src)
        for n = 0 to display_count - 1
            int best_pos = -1
            float best_val = na
            for j = 0 to level_count - 1
                float poc_val = f_safe_get(kl_poc_buffer, j)
                if not na(poc_val) and (na(best_val) or poc_val > best_val)
                    best_val := poc_val
                    best_pos := j
            if best_pos >= 0 and best_pos < array.size(kl_poc_buffer)
                array.push(kl_price_order, best_pos)
                array.set(kl_poc_buffer, best_pos, na)

    for row = 0 to key_data_rows - 1
        int data_row = row + 2
        if row < display_count and row < array.size(kl_price_order)
            int level_idx = array.get(kl_price_order, row)
            bool level_idx_ok = level_idx >= 0 and level_idx < array.size(kl_range_top) and level_idx < array.size(kl_range_bottom) and level_idx < array.size(kl_poc) and level_idx < array.size(kl_side) and level_idx < array.size(kl_peak_ratio) and level_idx < array.size(kl_net_delta) and level_idx < array.size(kl_total_volume) and level_idx < array.size(kl_tier) and level_idx < array.size(kl_strength) and level_idx < array.size(kl_state) and level_idx < array.size(kl_test_count) and level_idx < array.size(kl_rr_ratio)
            if not level_idx_ok
                continue
            float range_top = array.get(kl_range_top, level_idx)
            float range_bottom = array.get(kl_range_bottom, level_idx)
            float poc = array.get(kl_poc, level_idx)
            string side = array.get(kl_side, level_idx)
            float peak_ratio = array.get(kl_peak_ratio, level_idx)
            float net_delta = array.get(kl_net_delta, level_idx)
            float total_vol = array.get(kl_total_volume, level_idx)
            string tier = array.get(kl_tier, level_idx)
            float strength = array.get(kl_strength, level_idx)
            string state = array.get(kl_state, level_idx)
            int tests = array.get(kl_test_count, level_idx)
            float rr = array.get(kl_rr_ratio, level_idx)

            color side_color = side == "buy" ? col_buy : col_sell
            color tier_bg = tier == TIER_EXTREME ? color.new(color.orange, 92) : tier == TIER_STRONG ? color.new(color.blue, 92) : color.new(color.black, 90)

            color state_color = color.white
            color row_bg = tier_bg

            if state == STATE_HELD
                state_color := color.yellow
                row_bg := color.new(color.yellow, 90)
            else if state == STATE_PROFIT
                state_color := color.lime
                row_bg := color.new(color.lime, 90)
            else if state == STATE_ENTRY
                state_color := color.orange
                row_bg := color.new(color.orange, 90)
            else if state == STATE_TESTING
                state_color := color.aqua
            else if state == STATE_CLOSED
                state_color := color.silver
                row_bg := color.new(color.gray, 90)
            // Losing trades are highlighted in red
            else if state == STATE_LOSS
                state_color := color.red
                row_bg := color.new(color.red, 90)
            else if state == STATE_ACTIVE
                state_color := color.white
            // Rejected trades are grey
            else if state == STATE_REJECTED
                state_color := color.gray
                row_bg := color.new(color.gray, 92)
            else
                state_color := color.gray

            string range_str = str.tostring(range_bottom, format.mintick) + "-" + str.tostring(range_top, format.mintick)
            string side_label = side == "buy" ? "B" : "S"
            float smart_delta = total_vol > 0 ? (net_delta / total_vol) * 100 : 0
            string delta_marker = smart_delta >= 0 ? "" : ""
            color delta_color = smart_delta >= 0 ? col_buy : col_sell
            string delta_label = str.tostring(math.abs(smart_delta), "#.0") + "% " + delta_marker

            // Use wider score bands so higher-strength levels stand out more aggressively.
            color score_color = strength >= 850 ? color.lime : strength >= 500 ? color.new(color.lime, 20) : strength >= 250 ? color.white : color.gray
            table.cell(tbl_key, 0, data_row, range_str, text_color=color.white, text_size=size.small, bgcolor=row_bg)
            table.cell(tbl_key, 1, data_row, str.tostring(poc, format.mintick), text_color=side_color, text_size=size.small, bgcolor=row_bg)
            table.cell(tbl_key, 2, data_row, side_label, text_color=side_color, text_size=size.small, bgcolor=row_bg)
            table.cell(tbl_key, 3, data_row, delta_label, text_color=delta_color, text_size=size.small, bgcolor=row_bg)
            table.cell(tbl_key, 4, data_row, str.tostring(math.round(strength)), text_color=score_color, text_size=size.small, bgcolor=row_bg)
        else
            color empty_bg = color.new(color.gray, 95)
            for col = 0 to 4
                table.cell(tbl_key, col, data_row, "-", text_color=color.gray, text_size=size.small, bgcolor=empty_bg)

// Order flow table renders independently so it is not blocked by other tables.
if barstate.islast and showTables and not na(tbl_flow)
    // ---------------------------------------------------------------------
    // Order flow table header and recent bars
    table.cell(tbl_flow, 0, 0, "ORDER FLOW HISTORY", text_color=color.white, text_size=size.normal, bgcolor=color.new(color.gray, 60))
    table.merge_cells(tbl_flow, 0, 0, 8, 0)

    int safe_bars = math.min(barsToShow, bar_index + 1)
    int current_row = 1

    for bar_idx = 0 to 2
        if bar_idx < safe_bars
            int col_start = bar_idx * 3
            int bar_offset = safe_bars - 1 - bar_idx
            string bar_label = "-" + str.tostring(bar_offset)
            table.cell(tbl_flow, col_start, current_row, bar_label, text_color=color.yellow, text_size=size.small, bgcolor=color.new(color.gray, 70))
            table.merge_cells(tbl_flow, col_start, current_row, col_start + 2, current_row)
    current_row += 1

    for bar_idx = 0 to 2
        if bar_idx < safe_bars
            int col_start = bar_idx * 3
            table.cell(tbl_flow, col_start + 0, current_row, "Price", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 75))
            table.cell(tbl_flow, col_start + 1, current_row, "B:S", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 75))
            table.cell(tbl_flow, col_start + 2, current_row, "", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 75))
    current_row += 1

    for row = 0 to 7
        for bar_idx = 0 to 2
            if bar_idx < safe_bars
                int col_start = bar_idx * 3
                int bar_offset = safe_bars - 1 - bar_idx
                [prices, buys, sells] = calc_bar_levels(bar_offset)
                int level_count_left = array.size(prices)
                if level_count_left > 0 and row < level_count_left
                    int idx = level_count_left - 1 - row
                    float price = array.get(prices, idx)
                    float buy_vol = array.get(buys, idx)
                    float sell_vol = array.get(sells, idx)
                    float delta = buy_vol - sell_vol
                    float ratio = buy_vol >= sell_vol ? buy_vol / math.max(sell_vol, 1) : sell_vol / math.max(buy_vol, 1)
                    bool is_imbalance = ratio >= imbalanceRatio
                    color row_bg = is_imbalance ? (buy_vol > sell_vol ? color.new(col_buy, 85) : color.new(col_sell, 85)) : color.new(color.black, 92)
                    table.cell(tbl_flow, col_start + 0, current_row, str.tostring(price, format.mintick), text_color=color.white, text_size=size.small, bgcolor=row_bg)
                    table.cell(tbl_flow, col_start + 1, current_row, str.tostring(math.round(buy_vol)) + ":" + str.tostring(math.round(sell_vol)), text_color=color.white, text_size=size.small, bgcolor=row_bg)
                    string delta_text = str.tostring(math.round(delta), "+#;-#") + (is_imbalance ? " " : "")
                    table.cell(tbl_flow, col_start + 2, current_row, delta_text, text_color=delta > 0 ? col_buy : col_sell, text_size=size.small, bgcolor=row_bg)
                else
                    color empty_bg = color.new(color.gray, 95)
                    table.cell(tbl_flow, col_start + 0, current_row, "-", text_color=color.gray, text_size=size.small, bgcolor=empty_bg)
                    table.cell(tbl_flow, col_start + 1, current_row, "-", text_color=color.gray, text_size=size.small, bgcolor=empty_bg)
                    table.cell(tbl_flow, col_start + 2, current_row, "-", text_color=color.gray, text_size=size.small, bgcolor=empty_bg)
        current_row += 1

    table.cell(tbl_flow, 0, current_row, "", bgcolor=color.new(color.gray, 80))
    table.merge_cells(tbl_flow, 0, current_row, 8, current_row)
    current_row += 1

    for bar_idx = 0 to 2
        int actual_bar_idx = bar_idx + 3
        if actual_bar_idx < safe_bars
            int col_start = bar_idx * 3
            int bar_offset = safe_bars - 1 - actual_bar_idx
            string bar_label = bar_offset == 0 ? "NOW" : "-" + str.tostring(bar_offset)
            table.cell(tbl_flow, col_start, current_row, bar_label, text_color=bar_offset == 0 ? color.lime : color.yellow, text_size=size.small, bgcolor=color.new(color.gray, 70))
            table.merge_cells(tbl_flow, col_start, current_row, col_start + 2, current_row)
    current_row += 1

    for bar_idx = 0 to 2
        int actual_bar_idx = bar_idx + 3
        if actual_bar_idx < safe_bars
            int col_start = bar_idx * 3
            table.cell(tbl_flow, col_start + 0, current_row, "Price", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 75))
            table.cell(tbl_flow, col_start + 1, current_row, "B:S", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 75))
            table.cell(tbl_flow, col_start + 2, current_row, "", text_color=color.white, text_size=size.small, bgcolor=color.new(color.gray, 75))
    current_row += 1

    for row = 0 to 7
        for bar_idx = 0 to 2
            int actual_bar_idx = bar_idx + 3
            if actual_bar_idx < safe_bars
                int col_start = bar_idx * 3
                int bar_offset = safe_bars - 1 - actual_bar_idx
                [prices, buys, sells] = calc_bar_levels(bar_offset)
                int level_count_right = array.size(prices)
                if level_count_right > 0 and row < level_count_right
                    int idx = level_count_right - 1 - row
                    float price = array.get(prices, idx)
                    float buy_vol = array.get(buys, idx)
                    float sell_vol = array.get(sells, idx)
                    float delta = buy_vol - sell_vol
                    float ratio = buy_vol >= sell_vol ? buy_vol / math.max(sell_vol, 1) : sell_vol / math.max(buy_vol, 1)
                    bool is_imbalance = ratio >= imbalanceRatio
                    color row_bg = is_imbalance ? (buy_vol > sell_vol ? color.new(col_buy, 85) : color.new(col_sell, 85)) : color.new(color.black, 92)
                    table.cell(tbl_flow, col_start + 0, current_row, str.tostring(price, format.mintick), text_color=color.white, text_size=size.small, bgcolor=row_bg)
                    table.cell(tbl_flow, col_start + 1, current_row, str.tostring(math.round(buy_vol)) + ":" + str.tostring(math.round(sell_vol)), text_color=color.white, text_size=size.small, bgcolor=row_bg)
                    string delta_text = str.tostring(math.round(delta), "+#;-#") + (is_imbalance ? " " : "")
                    table.cell(tbl_flow, col_start + 2, current_row, delta_text, text_color=delta > 0 ? col_buy : col_sell, text_size=size.small, bgcolor=row_bg)
                else
                    color empty_bg = color.new(color.gray, 95)
                    table.cell(tbl_flow, col_start + 0, current_row, "-", text_color=color.gray, text_size=size.small, bgcolor=empty_bg)
                    table.cell(tbl_flow, col_start + 1, current_row, "-", text_color=color.gray, text_size=size.small, bgcolor=empty_bg)
                    table.cell(tbl_flow, col_start + 2, current_row, "-", text_color=color.gray, text_size=size.small, bgcolor=empty_bg)
        current_row += 1

 
